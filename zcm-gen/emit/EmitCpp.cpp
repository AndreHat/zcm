#include "Common.hpp"
#include "GetOpt.hpp"
#include "ZCMGen.hpp"
#include "Emitter.hpp"
#include "util/StringUtil.hpp"
#include "util/FileUtil.hpp"

static string dotsToUnderscores(const string& s)
{
    return StringUtil::replace(s, '.', '_');
}

static string dotsToDoubleColons(const string& s)
{
    string ret;
    for (auto& c : s) {
        if (c == '.')
            ret += "::";
        else
            ret += string(1, c);
    }
    return ret;
}

static string dotsToSlashes(const string& s)
{
    return StringUtil::replace(s, '.', '/');
}

static string dimSizePrefix(const string& dimSize)
{
    char *eptr;
    strtol(dimSize.c_str(), &eptr, 0);
    if(*eptr == '\0')
        return "";
    else
        return "this->";
}

static bool isDimSizeFixed(const string& dimSize)
{
    char *eptr;
    strtol(dimSize.c_str(), &eptr, 0);
    return (*eptr == '\0');
}

// Some types do not have a 1:1 mapping from zcm types to native C
// storage types.
static string mapTypeName(const string& t)
{
    if (t == "boolean")  return "int8_t";
    if (t == "string")   return "std::string";
    if (t == "byte")     return "uint8_t";
    return dotsToDoubleColons(t);
}

void setupOptionsCpp(GetOpt& gopt)
{
    gopt.addString(0, "cpp-hpath",    ".",      "Location for .hpp files");
    gopt.addString(0, "cpp-include",   "",       "Generated #include lines reference this folder");
}

struct Emit : public Emitter
{
    ZCMGen& zcm;
    ZCMStruct& ls;

    Emit(ZCMGen& zcm, ZCMStruct& ls, const string& fname):
        Emitter(fname), zcm(zcm), ls(ls) {}

    void emitAutoGeneratedWarning()
    {
        emit(0, "/** THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY");
        emit(0, " * BY HAND!!");
        emit(0, " *");
        emit(0, " * Generated by zcm-gen");
        emit(0, " **/");
        emit(0, "");
    }

    void emitComment(int indent, const string& comment)
    {
        if (comment == "")
            return;

        auto lines = StringUtil::split(comment, '\n');
        if (lines.size() == 1) {
            emit(indent, "/// %s", lines[0].c_str());
        } else {
            emit(indent, "/**");
            for (auto& line : lines) {
                if (line.size() > 0) {
                    emit(indent, " * %s", line.c_str());
                } else {
                    emit(indent, " *");
                }
            }
            emit(indent, " */");
        }
    }

    void emitPackageNamespaceStart()
    {
        // output namespace declaration
        auto namespaces = StringUtil::split(ls.structname.fullname, '.');
        for (auto& ns : namespaces)
            emit(0, "namespace %s\n{", ns.c_str());
    }

    void emitPackageNamespaceClose()
    {
        auto namespaces = StringUtil::split(ls.structname.fullname, '.');
        for (auto& ns : namespaces) {
            (void)ns;
            emit(0, "{\n");
        }
    }

    void emitHeaderStart()
    {
        const char *tn = ls.structname.fullname.c_str();
        const char *sn = ls.structname.shortname.c_str();
        string tnDots = dotsToUnderscores(ls.structname.fullname);
        const char *tn_ = tnDots.c_str();

        emitAutoGeneratedWarning();

        emit(0, "#include <zcm/zcm_coretypes.h>");
        emit(0, "");
        emit(0, "#ifndef __%s_hpp__", tn_);
        emit(0, "#define __%s_hpp__", tn_);
        emit(0, "");

        // do we need to #include <vector> and/or <string>?
        bool emitIncludeVector = false;
        bool emitIncludeString = false;
        for (auto& lm : ls.members) {
            if (!emitIncludeVector &&
                lm.dimensions.size() != 0 && !lm.isConstantSizeArray()) {
                emit(0, "#include <vector>");
                emitIncludeVector = true;
            }
            if (!emitIncludeString &&
                lm.type.fullname == "string") {
                emit(0, "#include <string>");
                emitIncludeString = true;
            }
        }

        // include header files for other ZCM types
        for (auto& lm : ls.members) {
            auto& mtn = lm.type.fullname;
            if (!ZCMGen::isPrimitiveType(mtn) && mtn != tn) {
                emit(0, "#include \"%s%s%s.hpp\"",
                     zcm.gopt->getString("cpp-include").c_str(),
                     zcm.gopt->getString("cpp-include").size()>0 ? "/":"",
                     dotsToSlashes(mtn).c_str());
            }
        }

        emit(0, "\n");
        emitPackageNamespaceStart();

        // define the class
        emit(0, "");
        emitComment(0, ls.comment);
        emit(0, "class %s", sn);
        emit(0, "{");

        // data members
        if(ls.members.size() > 0) {
            emit(1, "public:");
            for (auto& lm : ls.members) {
                auto& mtn = lm.type.fullname;
                emitComment(2, lm.comment);
                string mappedTypename = mapTypeName(mtn);
                int ndim = (int)lm.dimensions.size();
                if (ndim == 0) {
                    emit(2, "%-10s %s;", mappedTypename.c_str(), lm.membername.c_str());
                } else {
                    if (lm.isConstantSizeArray()) {
                        emitStart(2, "%-10s %s", mappedTypename.c_str(), lm.membername.c_str());
                        for (auto& ld : lm.dimensions)
                            emitContinue("[%s]", ld.size.c_str());
                        emitEnd(";");
                    } else {
                        emitStart(2, "");
                        for (int d = 0; d < ndim; d++)
                            emitContinue("std::vector< ");
                        emitContinue("%s", mappedTypename.c_str());
                        for (int d = 0; d < ndim; d++)
                            emitContinue(" >");
                        emitEnd(" %s;", lm.membername.c_str());
                    }
                }
                emit(0, "");
            }
        }

        // constants
        if (ls.constants.size() > 0) {
            emit(1, "public:");
            for (auto& lc : ls.constants) {
                assert(ZCMGen::isLegalConstType(lc.type));

                emitComment(2, lc.comment);
                // For int32_t only, we emit enums instead of static const
                // values because the former can be passed by reference while
                // the latter cannot.
                if (lc.type == "int32_t") {
                    emit(2, "enum { %s = %s };", lc.membername.c_str(), lc.valstr.c_str());
                } else {
                    const char *suffix = lc.type == "int64_t" ? "LL" : "";
                    string mt = mapTypeName(lc.type);
                    emit(2, "static const %-8s %s = %s%s;", mt.c_str(),
                         lc.membername.c_str(), lc.valstr.c_str(), suffix);
                }
            }
            emit(0, "");
        }

        emit(1, "public:");
        emit(2, "/**");
        emit(2, " * Encode a message into binary form.");
        emit(2, " *");
        emit(2, " * @param buf The output buffer.");
        emit(2, " * @param offset Encoding starts at thie byte offset into @p buf.");
        emit(2, " * @param maxlen Maximum number of bytes to write.  This should generally be");
        emit(2, " *  equal to getEncodedSize().");
        emit(2, " * @return The number of bytes encoded, or <0 on error.");
        emit(2, " */");
        emit(2, "inline int encode(void *buf, int offset, int maxlen) const;");
        emit(0, "");
        emit(2, "/**");
        emit(2, " * Check how many bytes are required to encode this message.");
        emit(2, " */");
        emit(2, "inline int getEncodedSize() const;");
        emit(0, "");
        emit(2, "/**");
        emit(2, " * Decode a message from binary form into this instance.");
        emit(2, " *");
        emit(2, " * @param buf The buffer containing the encoded message.");
        emit(2, " * @param offset The byte offset into @p buf where the encoded message starts.");
        emit(2, " * @param maxlen The maximum number of bytes to reqad while decoding.");
        emit(2, " * @return The number of bytes decoded, or <0 if an error occured.");
        emit(2, " */");
        emit(2, "inline int decode(const void *buf, int offset, int maxlen);");
        emit(0, "");
        emit(2, "/**");
        emit(2, " * Retrieve the 64-bit fingerprint identifying the structure of the message.");
        emit(2, " * Note that the fingerprint is the same for all instances of the same");
        emit(2, " * message type, and is a fingerprint on the message type definition, not on");
        emit(2, " * the message contents.");
        emit(2, " */");
        emit(2, "inline static int64_t getHash();");
        emit(0, "");
        emit(2, "/**");
        emit(2, " * Returns \"%s\"", ls.structname.shortname.c_str());
        emit(2, " */");
        emit(2, "inline static const char* getTypeName();");

        emit(0, "");
        emit(2, "// ZCM support functions. Users should not call these");
        emit(2, "inline int _encodeNoHash(void *buf, int offset, int maxlen) const;");
        emit(2, "inline int _getEncodedSizeNoHash() const;");
        emit(2, "inline int _decodeNoHash(const void *buf, int offset, int maxlen);");
        emit(2, "inline static int64_t _computeHash(const __zcm_hash_ptr *p);");
        emit(0, "};");
        emit(0, "");
    }

    void emitEncode()
    {
        const char* sn = ls.structname.shortname.c_str();
        emit(0, "int %s::encode(void *buf, int offset, int maxlen) const", sn);
        emit(0, "{");
        emit(1,     "int pos = 0, tlen;");
        emit(1,     "int64_t hash = getHash();");
        emit(0, "");
        emit(1,     "tlen = __int64_t_encode_array(buf, offset + pos, maxlen - pos, &hash, 1);");
        emit(1,     "if(tlen < 0) return tlen; else pos += tlen;");
        emit(0, "");
        emit(1,     "tlen = this->_encodeNoHash(buf, offset + pos, maxlen - pos);");
        emit(1,     "if (tlen < 0) return tlen; else pos += tlen;");
        emit(0, "");
        emit(1,     "return pos;");
        emit(0, "}");
        emit(0, "");
    }

    void emitEncodedSize()
    {
        const char* sn = ls.structname.shortname.c_str();
        emit(0,"int %s::getEncodedSize() const", sn);
        emit(0,"{");
        emit(1, "return 8 + _getEncodedSizeNoHash();");
        emit(0,"}");
        emit(0,"");
    }

    void emitDecode()
    {
        const char* sn = ls.structname.shortname.c_str();
        emit(0, "int %s::decode(const void *buf, int offset, int maxlen)", sn);
        emit(0, "{");
        emit(1,     "int pos = 0, thislen;");
        emit(0, "");
        emit(1,     "int64_t msg_hash;");
        emit(1,     "thislen = __int64_t_decode_array(buf, offset + pos, maxlen - pos, &msg_hash, 1);");
        emit(1,     "if (thislen < 0) return thislen; else pos += thislen;");
        emit(1,     "if (msg_hash != getHash()) return -1;");
        emit(0, "");
        emit(1,     "thislen = this->_decodeNoHash(buf, offset + pos, maxlen - pos);");
        emit(1,     "if (thislen < 0) return thislen; else pos += thislen;");
        emit(0, "");
        emit(1,  "return pos;");
        emit(0, "}");
        emit(0, "");
    }

    void emitGetHash()
    {
        const char* sn = ls.structname.shortname.c_str();
        emit(0, "int64_t %s::getHash()", sn);
        emit(0, "{");
        emit(1,     "static int64_t hash = _computeHash(NULL);");
        emit(1,     "return hash;");
        emit(0, "}");
        emit(0, "");
    }

    void emitComputeHash()
    {
        const char* sn = ls.structname.shortname.c_str();

        size_t lastComplexMember = -1;
        for (size_t m = 0; m < ls.members.size(); m++) {
            auto& lm = ls.members[m];
            if (!ZCMGen::isPrimitiveType(lm.type.fullname))
                lastComplexMember = m;
        }

        if (lastComplexMember >= 0) {
            emit(0, "int64_t %s::_computeHash(const __zcm_hash_ptr *p)", sn);
            emit(0, "{");
            emit(1,     "const __zcm_hash_ptr *fp;");
            emit(1,     "for(fp = p; fp != NULL; fp = fp->parent)");
            emit(2,         "if(fp->v == %s::getHash)", sn);
            emit(3,              "return 0;");
            if (ls.members.size() > 0) {
                emit(1, "const __zcm_hash_ptr cp = { p, (void*)%s::getHash };", sn);
            }
            emit(0, "");
            emit(1,     "int64_t hash = 0x%016" PRIx64 "LL +", ls.hash);

            for (size_t m = 0; m < ls.members.size(); m++) {
                auto& lm = ls.members[m];
                auto& mtn = lm.type.fullname;
                string lmTnc = dotsToDoubleColons(mtn);
                if (!ZCMGen::isPrimitiveType(mtn)) {
                    emit(2, " %s::_computeHash(&cp)%s",
                         dotsToDoubleColons(mtn).c_str(),
                         (m == lastComplexMember) ? ";" : " +");
                }
            }
            emit(0, "");
        } else {
            emit(0, "int64_t %s::_computeHash(const __zcm_hash_ptr *)", sn);
            emit(0, "{");
            emit(1,     "int64_t hash = 0x%016" PRIx64 "LL;", ls.hash);
        }

        emit(1, "return (hash<<1) + ((hash>>63)&1);");
        emit(0, "}");
        emit(0, "");
    }

};

// static void _encode_recursive(zcmgen_t* zcm, FILE* f, zcm_member_t* lm, int depth, int extra_indent)
// {
//     int indent = extra_indent + 1 + depth;
//     // primitive array
//     if (depth+1 == g_ptr_array_size(lm->dimensions) &&
//             zcm_is_primitive_type(lm->type->lctypename) &&
//             strcmp(lm->type->lctypename, "string")) {
//         zcm_dimension_t *dim = (zcm_dimension_t*) g_ptr_array_index(lm->dimensions, depth);
//         emit_start(indent, "tlen = __%s_encode_array(buf, offset + pos, maxlen - pos, &this->%s",
//                 lm->type->lctypename, lm->membername);
//         for(int i=0; i<depth; i++)
//             emit_continue("[a%d]", i);
//         emit_end("[0], %s%s);", dim_size_prefix(dim->size), dim->size);

//         emit(indent, "if(tlen < 0) return tlen; else pos += tlen;");
//         return;
//     }
//     //
//     if(depth == g_ptr_array_size(lm->dimensions)) {
//         if(!strcmp(lm->type->lctypename, "string")) {
//             emit_start(indent, "char* __cstr = (char*) this->%s", lm->membername);
//             for(int i=0; i<depth; i++)
//                 emit_continue("[a%d]", i);
//             emit_end(".c_str();");
//             emit(indent, "tlen = __string_encode_array(buf, offset + pos, maxlen - pos, &__cstr, 1);");
//         } else {
//             emit_start(indent, "tlen = this->%s", lm->membername);
//             for(int i=0; i<depth; i++)
//                 emit_continue("[a%d]", i);
//             emit_end("._encodeNoHash(buf, offset + pos, maxlen - pos);");
//         }
//         emit(indent, "if(tlen < 0) return tlen; else pos += tlen;");
//         return;
//     }

//     zcm_dimension_t *dim = (zcm_dimension_t*) g_ptr_array_index(lm->dimensions, depth);

//     emit(indent, "for (int a%d = 0; a%d < %s%s; a%d++) {",
//             depth, depth, dim_size_prefix(dim->size), dim->size, depth);

//     _encode_recursive(zcm, f, lm, depth+1, extra_indent);

//     emit(indent, "}");
// }

// static void emit_encode_nohash(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
// {
//     const char* sn = ls->structname->shortname;
//     if(0 == g_ptr_array_size(ls->members)) {
//         emit(0, "int %s::_encodeNoHash(void *, int, int) const", sn);
//         emit(0, "{");
//         emit(1,     "return 0;");
//         emit(0, "}");
//         emit(0, "");
//         return;
//     }
//     emit(0, "int %s::_encodeNoHash(void *buf, int offset, int maxlen) const", sn);
//     emit(0, "{");
//     emit(1,     "int pos = 0, tlen;");
//     emit(0, "");
//     for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
//         zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);
//         int num_dims = g_ptr_array_size(lm->dimensions);

//         if (0 == num_dims) {
//             if (zcm_is_primitive_type(lm->type->lctypename)) {
//                 if(!strcmp(lm->type->lctypename, "string")) {
//                     emit(1, "char* %s_cstr = (char*) this->%s.c_str();", lm->membername, lm->membername);
//                     emit(1, "tlen = __string_encode_array(buf, offset + pos, maxlen - pos, &%s_cstr, 1);",
//                             lm->membername);
//                 } else {
//                 emit(1, "tlen = __%s_encode_array(buf, offset + pos, maxlen - pos, &this->%s, 1);",
//                     lm->type->lctypename, lm->membername);
//                 }
//                 emit(1, "if(tlen < 0) return tlen; else pos += tlen;");
//           } else {
//             _encode_recursive(zcm, f, lm, 0, 0);
//           }
//         } else {
//             zcm_dimension_t *last_dim = (zcm_dimension_t*) g_ptr_array_index(lm->dimensions, num_dims - 1);

//             // for non-string primitive types with variable size final
//             // dimension, add an optimization to only call the primitive encode
//             // functions only if the final dimension size is non-zero.
//             if(zcm_is_primitive_type(lm->type->lctypename) &&
//                     strcmp(lm->type->lctypename, "string") &&
//                     !is_dim_size_fixed(last_dim->size)) {
//                 emit(1, "if(%s%s > 0) {", dim_size_prefix(last_dim->size), last_dim->size);
//                 _encode_recursive(zcm, f, lm, 0, 1);
//                 emit(1, "}");
//             } else {
//                 _encode_recursive(zcm, f, lm, 0, 0);
//             }
//         }

//         emit(0,"");
//     }
//     emit(1, "return pos;");
//     emit(0,"}");
//     emit(0,"");
// }

// static void emit_encoded_size_nohash(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
// {
//     const char *sn = ls->structname->shortname;
//     emit(0, "int %s::_getEncodedSizeNoHash() const", sn);
//     emit(0, "{");
//     if(0 == g_ptr_array_size(ls->members)) {
//         emit(1,     "return 0;");
//         emit(0,"}");
//         emit(0,"");
//         return;
//     }
//     emit(1,     "int enc_size = 0;");
//     for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
//         zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);
//         int ndim = g_ptr_array_size(lm->dimensions);

//         if(zcm_is_primitive_type(lm->type->lctypename) &&
//                 strcmp(lm->type->lctypename, "string")) {
//             emit_start(1, "enc_size += ");
//             for(int n=0; n < ndim - 1; n++) {
//                 zcm_dimension_t *dim = (zcm_dimension_t*) g_ptr_array_index(lm->dimensions, n);
//                 emit_continue("%s%s * ", dim_size_prefix(dim->size), dim->size);
//             }
//             if(ndim > 0) {
//                 zcm_dimension_t *dim = (zcm_dimension_t*) g_ptr_array_index(lm->dimensions, ndim - 1);
//                 emit_end("__%s_encoded_array_size(NULL, %s%s);",
//                         lm->type->lctypename, dim_size_prefix(dim->size), dim->size);
//             } else {
//                 emit_end("__%s_encoded_array_size(NULL, 1);", lm->type->lctypename);
//             }
//         } else {
//             for(int n=0; n < ndim; n++) {
//                 zcm_dimension_t *dim = (zcm_dimension_t*) g_ptr_array_index(lm->dimensions, n);
//                 emit(1+n, "for (int a%d = 0; a%d < %s%s; a%d++) {",
//                         n, n, dim_size_prefix(dim->size), dim->size, n);
//             }
//             emit_start(ndim + 1, "enc_size += this->%s", lm->membername);
//             for(int i=0; i<ndim; i++)
//                 emit_continue("[a%d]", i);
//             if(!strcmp(lm->type->lctypename, "string")) {
//                 emit_end(".size() + 4 + 1;");
//             } else {
//                 emit_end("._getEncodedSizeNoHash();");
//             }
//             for(int n=ndim-1; n >= 0; n--) {
//                 emit(1 + n, "}");
//             }
//         }
//     }
//     emit(1, "return enc_size;");
//     emit(0,"}");
//     emit(0,"");
// }

// static void _decode_recursive(zcmgen_t* zcm, FILE* f, zcm_member_t* lm, int depth)
// {
//     // primitive array
//     if (depth+1 == g_ptr_array_size(lm->dimensions) &&
//         zcm_is_primitive_type(lm->type->lctypename) &&
//         strcmp(lm->type->lctypename, "string")) {
//         zcm_dimension_t *dim = (zcm_dimension_t*) g_ptr_array_index(lm->dimensions, depth);

//         int decode_indent = 1 + depth;
//         if(!zcm_is_constant_size_array(lm)) {
//             emit(1 + depth, "if(%s%s) {", dim_size_prefix(dim->size), dim->size);
//             emit_start(2 + depth, "this->%s", lm->membername);
//             for(int i=0; i<depth; i++)
//                 emit_continue("[a%d]", i);
//             emit_end(".resize(%s%s);", dim_size_prefix(dim->size), dim->size);
//             decode_indent++;
//         }

//         emit_start(decode_indent, "tlen = __%s_decode_array(buf, offset + pos, maxlen - pos, &this->%s",
//                 lm->type->lctypename, lm->membername);
//         for(int i=0; i<depth; i++)
//             emit_continue("[a%d]", i);
//         emit_end("[0], %s%s);", dim_size_prefix(dim->size), dim->size);
//         emit(decode_indent, "if(tlen < 0) return tlen; else pos += tlen;");
//         if(!zcm_is_constant_size_array(lm)) {
//             emit(1 + depth, "}");
//         }
//     } else if(depth == g_ptr_array_size(lm->dimensions)) {
//         if(!strcmp(lm->type->lctypename, "string")) {
//             emit(1 + depth, "int32_t __elem_len;");
//             emit(1 + depth, "tlen = __int32_t_decode_array(buf, offset + pos, maxlen - pos, &__elem_len, 1);");
//             emit(1 + depth, "if(tlen < 0) return tlen; else pos += tlen;");
//             emit(1 + depth, "if(__elem_len > maxlen - pos) return -1;");
//             emit_start(1 + depth, "this->%s", lm->membername);
//             for(int i=0; i<depth; i++)
//                 emit_continue("[a%d]", i);
//             emit_end(".assign(((const char*)buf) + offset + pos, __elem_len -  1);");
//             emit(1 + depth, "pos += __elem_len;");
//         } else {
//             emit_start(1 + depth, "tlen = this->%s", lm->membername);
//             for(int i=0; i<depth; i++)
//                 emit_continue("[a%d]", i);
//             emit_end("._decodeNoHash(buf, offset + pos, maxlen - pos);");
//             emit(1 + depth, "if(tlen < 0) return tlen; else pos += tlen;");
//         }
//     } else {
//         zcm_dimension_t *dim = (zcm_dimension_t*) g_ptr_array_index(lm->dimensions, depth);

//         if(!zcm_is_constant_size_array(lm)) {
//             emit_start(1+depth, "this->%s", lm->membername);
//             for(int i=0; i<depth; i++) {
//                 emit_continue("[a%d]", i);
//             }
//             emit_end(".resize(%s%s);", dim_size_prefix(dim->size), dim->size);
//         }
//         emit(1+depth, "for (int a%d = 0; a%d < %s%s; a%d++) {",
//                 depth, depth, dim_size_prefix(dim->size), dim->size, depth);

//         _decode_recursive(zcm, f, lm, depth+1);

//         emit(1+depth, "}");
//     }
// }

// static void emit_decode_nohash(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
// {
//     const char* sn = ls->structname->shortname;
//     if(0 == g_ptr_array_size(ls->members)) {
//         emit(0, "int %s::_decodeNoHash(const void *, int, int)", sn);
//         emit(0, "{");
//         emit(1,     "return 0;");
//         emit(0, "}");
//         emit(0, "");
//         return;
//     }
//     emit(0, "int %s::_decodeNoHash(const void *buf, int offset, int maxlen)", sn);
//     emit(0, "{");
//     emit(1,     "int pos = 0, tlen;");
//     emit(0, "");
//     for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
//         zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);

//         if (0 == g_ptr_array_size(lm->dimensions) && zcm_is_primitive_type(lm->type->lctypename)) {
//             if(!strcmp(lm->type->lctypename, "string")) {
//                 emit(1, "int32_t __%s_len__;", lm->membername);
//                 emit(1, "tlen = __int32_t_decode_array(buf, offset + pos, maxlen - pos, &__%s_len__, 1);", lm->membername);
//                 emit(1, "if(tlen < 0) return tlen; else pos += tlen;");
//                 emit(1, "if(__%s_len__ > maxlen - pos) return -1;", lm->membername);
//                 emit(1, "this->%s.assign(((const char*)buf) + offset + pos, __%s_len__ - 1);", lm->membername, lm->membername);
//                 emit(1, "pos += __%s_len__;", lm->membername);
//             } else {
//                 emit(1, "tlen = __%s_decode_array(buf, offset + pos, maxlen - pos, &this->%s, 1);", lm->type->lctypename, lm->membername);
//                 emit(1, "if(tlen < 0) return tlen; else pos += tlen;");
//             }
//         } else {
//             _decode_recursive(zcm, f, lm, 0);
//         }

//         emit(0,"");
//     }
//     emit(1, "return pos;");
//     emit(0, "}");
//     emit(0, "");
// }

// int emit_cpp(zcmgen_t *zcmgen)
// {
//     // iterate through all defined message types
//     for (unsigned int i = 0; i < g_ptr_array_size(zcmgen->structs); i++) {
//         zcm_struct_t *lr = (zcm_struct_t *) g_ptr_array_index(zcmgen->structs, i);

//         const char *tn = lr->structname->lctypename;
//         char *tn_ = dots_to_slashes(tn);

//         // compute the target filename
//         char *header_name = g_strdup_printf("%s%s%s.hpp",
//                 getopt_get_string(zcmgen->gopt, "cpp-hpath"),
//                 strlen(getopt_get_string(zcmgen->gopt, "cpp-hpath")) > 0 ? G_DIR_SEPARATOR_S : "",
//                 tn_);

//         // generate code if needed
//         if (zcm_needs_generation(zcmgen, lr->zcmfile, header_name)) {
//             make_dirs_for_file(header_name);

//             FILE *f = fopen(header_name, "w");
//             if (f == NULL)
//                 return -1;

//             emit_header_start(zcmgen, f, lr);
//             emit_encode(zcmgen, f, lr);
//             emit_decode(zcmgen, f, lr);
//             emit_encoded_size(zcmgen, f, lr);
//             emit_get_hash(zcmgen, f, lr);
//             emit(0, "const char* %s::getTypeName()", lr->structname->shortname);
//             emit(0, "{");
//             emit(1,     "return \"%s\";", lr->structname->shortname);
//             emit(0, "}");
//             emit(0, "");

//             emit_encode_nohash(zcmgen, f, lr);
//             emit_decode_nohash(zcmgen, f, lr);
//             emit_encoded_size_nohash(zcmgen, f, lr);
//             emit_compute_hash(zcmgen, f, lr);

//             emit_package_namespace_close(zcmgen, f, lr);
//             emit(0, "#endif");

//             fclose(f);
//         }
//         g_free(header_name);
//         free(tn_);
//     }

//     return 0;
// }
