#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#ifdef WIN32
#define __STDC_FORMAT_MACROS			// Enable integer types
#endif
#include <inttypes.h>

#include "zcmgen.h"


#define INDENT(n) (4*(n))

#define emit_start(n, ...) do { fprintf(f, "%*s", INDENT(n), ""); fprintf(f, __VA_ARGS__); } while (0)
#define emit_continue(...) do { fprintf(f, __VA_ARGS__); } while (0)
#define emit_end(...) do { fprintf(f, __VA_ARGS__); fprintf(f, "\n"); } while (0)
#define emit(n, ...) do { fprintf(f, "%*s", INDENT(n), ""); fprintf(f, __VA_ARGS__); fprintf(f, "\n"); } while (0)

#define FLAG_NONE 0

// flags for emit_c_array_loops_start
#define FLAG_EMIT_MALLOCS 1

// flags for emit_c_array_loops_end
#define FLAG_EMIT_FREES   2

static inline int imax(int a, int b)
{
    return (a > b) ? a : b;
}

static char *dots_to_underscores(const char *s)
{
    char *p = strdup(s);

    for (char *t=p; *t!=0; t++)
        if (*t == '.')
            *t = '_';

    return p;
}


static void emit_auto_generated_warning(FILE *f)
{
    fprintf(f,
            "// THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY\n"
            "// BY HAND!!\n"
            "//\n"
            "// Generated by zcm-gen\n\n");
}


// Some types do not have a 1:1 mapping from zcm types to native C
// storage types. Do not free the string pointers returned by this
// function.
static const char *map_type_name(const char *t)
{
    if (!strcmp(t,"boolean"))
        return "int8_t";

    if (!strcmp(t,"string"))
        return "char*";

    if (!strcmp(t,"byte"))
        return "uint8_t";

    return dots_to_underscores (t);
}

void setup_c_options(getopt_t *gopt)
{
    getopt_add_string (gopt, 0, "c-cpath",    ".",      "Location for .c files");
    getopt_add_string (gopt, 0, "c-hpath",    ".",      "Location for .h files");
    getopt_add_string (gopt, 0, "cinclude",   "",       "Generated #include lines reference this folder");
    getopt_add_bool   (gopt, 0, "c-no-pubsub",   0,     "Do not generate _publish and _subscribe functions");
    getopt_add_bool   (gopt, 0, "c-typeinfo",   0,      "Generate typeinfo functions for each type");
}

/** Emit output that is common to every header file **/
static void emit_header_top(zcmgen_t *zcm, FILE *f, char *name)
{
    emit_auto_generated_warning(f);

    fprintf(f, "#include <stdint.h>\n");
    fprintf(f, "#include <stdlib.h>\n");
    fprintf(f, "#include <zcm/zcm_coretypes.h>\n");
//    fprintf(f, "#include \"%s%szcm_lib.h\"\n",
//            getopt_get_string(zcm->gopt, "cinclude"),
//            strlen(getopt_get_string(zcm->gopt, "cinclude"))>0 ? "/" : "");

    if(!getopt_get_bool(zcm->gopt, "c-no-pubsub")) {
        fprintf(f, "#include <zcm/zcm.h>\n");
    }
    fprintf(f, "\n");

    fprintf(f, "#ifndef _%s_h\n", name);
    fprintf(f, "#define _%s_h\n", name);
    fprintf(f, "\n");

    fprintf(f, "#ifdef __cplusplus\n");
    fprintf(f, "extern \"C\" {\n");
    fprintf(f, "#endif\n");
    fprintf(f, "\n");

}

/** Emit output that is common to every header file **/
static void emit_header_bottom(zcmgen_t *zcm, FILE *f)
{
    fprintf(f, "#ifdef __cplusplus\n");
    fprintf(f, "}\n");
    fprintf(f, "#endif\n");
    fprintf(f, "\n");
    fprintf(f, "#endif\n");
}

static void emit_comment(FILE* f, int indent, const char* comment) {
    if (!comment)
        return;

    gchar** lines = g_strsplit(comment, "\n", 0);
    int num_lines = 0;
    for (num_lines = 0; lines[num_lines]; num_lines++) {}

    if (num_lines == 1) {
        emit(indent, "/// %s", lines[0]);
    } else {
        emit(indent, "/**");
        for (int line_ind = 0; lines[line_ind]; line_ind++) {
            if (strlen(lines[line_ind])) {
                emit(indent, " * %s", lines[line_ind]);
            } else {
                emit(indent, " *");
            }
        }
        emit(indent, " */");
    }
    g_strfreev(lines);
}

/** Emit header file output specific to a particular type of struct. **/
static void emit_header_struct(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);
    char *tn_upper = g_utf8_strup(tn_, -1);

    // include header files required by members
    for (unsigned int i = 0; i < g_ptr_array_size(ls->members); i++) {
        zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, i);

        if (!zcm_is_primitive_type(lm->type->lctypename) &&
             strcmp(lm->type->lctypename, ls->structname->lctypename)) {
            char *other_tn = dots_to_underscores (lm->type->lctypename);
            fprintf(f, "#include \"%s%s%s.h\"\n",
                    getopt_get_string(zcm->gopt, "cinclude"),
                    strlen(getopt_get_string(zcm->gopt, "cinclude"))>0 ? "/" : "",
                    other_tn);
            free (other_tn);
        }
    }

    // output constants
    for (unsigned int i = 0; i < g_ptr_array_size(ls->constants); i++) {
        zcm_constant_t *lc = (zcm_constant_t *) g_ptr_array_index(ls->constants, i);
        assert(zcm_is_legal_const_type(lc->lctypename));
        const char *suffix = "";
        if (!strcmp(lc->lctypename, "int64_t")) {
            suffix = "LL";
        }
        emit_comment(f, 0, lc->comment);
        emit(0, "#define %s_%s %s%s", tn_upper, lc->membername, lc->val_str,
                suffix);
    }
    if (g_ptr_array_size(ls->constants) > 0) {
        emit(0, "");
    }

    // define the struct
    emit_comment(f, 0, ls->comment);
    emit(0, "typedef struct _%s %s;", tn_, tn_);
    emit(0, "struct _%s", tn_);
    emit(0, "{");

    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);

        emit_comment(f, 1, lm->comment);

        int ndim = g_ptr_array_size(lm->dimensions);
        if (ndim == 0) {
            emit(1, "%-10s %s;", map_type_name(lm->type->lctypename),
                    lm->membername);
        } else {
            if (zcm_is_constant_size_array(lm)) {
                emit_start(1, "%-10s %s", map_type_name(lm->type->lctypename), lm->membername);
                for (unsigned int d = 0; d < ndim; d++) {
                    zcm_dimension_t *ld = (zcm_dimension_t *) g_ptr_array_index(lm->dimensions, d);
                    emit_continue("[%s]", ld->size);
                }
                emit_end(";");
            } else {
                emit_start(1, "%-10s ", map_type_name(lm->type->lctypename));
                for (unsigned int d = 0; d < ndim; d++)
                    emit_continue("*");
                emit_end("%s;", lm->membername);
            }
        }
    }
    emit(0, "};");
    emit(0, "");

    free(tn_);
    g_free(tn_upper);
}

static void emit_header_prototypes(zcmgen_t *zcmgen, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0, "/**");
    emit(0, " * Create a deep copy of a %s.", tn_);
    emit(0, " * When no longer needed, destroy it with %s_destroy()", tn_);
    emit(0, " */");
    emit(0,"%s* %s_copy(const %s* to_copy);", tn_, tn_, tn_);
    emit(0, "");
    emit(0, "/**");
    emit(0, " * Destroy an instance of %s created by %s_copy()", tn_, tn_);
    emit(0, " */");
    emit(0,"void %s_destroy(%s* to_destroy);", tn_, tn_);
    emit(0,"");

    if (!getopt_get_bool(zcmgen->gopt, "c-no-pubsub")) {
        emit(0, "/**");
        emit(0, " * Identifies a single subscription.  This is an opaque data type.");
        emit(0, " */");
        emit(0,"typedef struct _%s_subscription_t %s_subscription_t;", tn_, tn_);
        emit(0, "");
        emit(0, "/**");
        emit(0, " * Prototype for a callback function invoked when a message of type");
        emit(0, " * %s is received.", tn_);
        emit(0, " */");
        emit(0,"typedef void(*%s_handler_t)(const zcm_recv_buf_t *rbuf,\n"
               "             const char *channel, const %s *msg, void *userdata);",
               tn_, tn_);
        emit(0, "");
        emit(0, "/**");
        emit(0, " * Publish a message of type %s using ZCM.", tn_);
        emit(0, " *");
        emit(0, " * @param zcm The ZCM instance to publish with.");
        emit(0, " * @param channel The channel to publish on.");
        emit(0, " * @param msg The message to publish.");
        emit(0, " * @return 0 on success, <0 on error.  Success means ZCM has transferred");
        emit(0, " * responsibility of the message data to the OS.");
        emit(0, " */");
        emit(0,"int %s_publish(zcm_t *zcm, const char *channel, const %s *msg);", tn_, tn_);
        emit(0, "");
        emit(0, "/**");
        emit(0, " * Subscribe to messages of type %s using ZCM.", tn_);
        emit(0, " *");
        emit(0, " * @param zcm The ZCM instance to subscribe with.");
        emit(0, " * @param channel The channel to subscribe to.");
        emit(0, " * @param handler The callback function invoked by ZCM when a message is received.");
        emit(0, " *                This function is invoked by ZCM during calls to zcm_handle() and");
        emit(0, " *                zcm_handle_timeout().");
        emit(0, " * @param userdata An opaque pointer passed to @p handler when it is invoked.");
        emit(0, " * @return 0 on success, <0 if an error occured");
        emit(0, " */");
        emit(0,"%s_subscription_t* %s_subscribe(zcm_t *zcm, const char *channel, %s_handler_t handler, void *userdata);",
                tn_, tn_, tn_);
        emit(0, "");
        emit(0, "/**");
        emit(0, " * Removes and destroys a subscription created by %s_subscribe()", tn_);
        emit(0, " */");
        emit(0,"int %s_unsubscribe(zcm_t *zcm, %s_subscription_t* hid);", tn_, tn_);
        emit(0, "");
        emit(0, "/**");
        emit(0, " * Sets the queue capacity for a subscription.");
        emit(0, " * Some ZCM providers (e.g., the default multicast provider) are implemented");
        emit(0, " * using a background receive thread that constantly revceives messages from");
        emit(0, " * the network.  As these messages are received, they are buffered on");
        emit(0, " * per-subscription queues until dispatched by zcm_handle().  This function");
        emit(0, " * how many messages are queued before dropping messages.");
        emit(0, " *");
        emit(0, " * @param subs the subscription to modify.");
        emit(0, " * @param num_messages The maximum number of messages to queue");
        emit(0, " *  on the subscription.");
        emit(0, " * @return 0 on success, <0 if an error occured");
        emit(0, " */");
        emit(0,"int %s_subscription_set_queue_capacity(%s_subscription_t* subs,\n"
            "                              int num_messages);\n", tn_, tn_);
    }

    emit(0, "/**");
    emit(0, " * Encode a message of type %s into binary form.", tn_);
    emit(0, " *");
    emit(0, " * @param buf The output buffer.");
    emit(0, " * @param offset Encoding starts at this byte offset into @p buf.");
    emit(0, " * @param maxlen Maximum number of bytes to write.  This should generally");
    emit(0, " *               be equal to %s_encoded_size().", tn_);
    emit(0, " * @param msg The message to encode.");
    emit(0, " * @return The number of bytes encoded, or <0 if an error occured.");
    emit(0, " */");
    emit(0,"int %s_encode(void *buf, int offset, int maxlen, const %s *p);", tn_, tn_);
    emit(0, "");
    emit(0, "/**");
    emit(0, " * Decode a message of type %s from binary form.", tn_);
    emit(0, " * When decoding messages containing strings or variable-length arrays, this");
    emit(0, " * function may allocate memory.  When finished with the decoded message,");
    emit(0, " * release allocated resources with %s_decode_cleanup().", tn_);
    emit(0, " *");
    emit(0, " * @param buf The buffer containing the encoded message");
    emit(0, " * @param offset The byte offset into @p buf where the encoded message starts.");
    emit(0, " * @param maxlen The maximum number of bytes to read while decoding.");
    emit(0, " * @param msg Output parameter where the decoded message is stored");
    emit(0, " * @return The number of bytes decoded, or <0 if an error occured.");
    emit(0, " */");
    emit(0,"int %s_decode(const void *buf, int offset, int maxlen, %s *msg);", tn_, tn_);
    emit(0, "");
    emit(0, "/**");
    emit(0, " * Release resources allocated by %s_decode()", tn_);
    emit(0, " * @return 0");
    emit(0, " */");
    emit(0,"int %s_decode_cleanup(%s *p);", tn_, tn_);
    emit(0, "");
    emit(0, "/**");
    emit(0, " * Check how many bytes are required to encode a message of type %s", tn_);
    emit(0, " */");
    emit(0,"int %s_encoded_size(const %s *p);", tn_, tn_);
    if(getopt_get_bool(zcmgen->gopt, "c-typeinfo")) {
        emit(0,"size_t %s_struct_size(void);", tn_);
        emit(0,"int  %s_num_fields(void);", tn_);
        emit(0,"int  %s_get_field(const %s *p, int i, zcm_field_t *f);", tn_, tn_);
        emit(0,"const zcm_type_info_t *%s_get_type_info(void);", tn_);
    }
    emit(0,"");

    emit(0,"// ZCM support functions. Users should not call these");
    emit(0,"int64_t __%s_get_hash(void);", tn_);
    emit(0,"int64_t __%s_hash_recursive(const __zcm_hash_ptr *p);", tn_);
    emit(0,"int     __%s_encode_array(void *buf, int offset, int maxlen, const %s *p, int elements);", tn_, tn_);
    emit(0,"int     __%s_decode_array(const void *buf, int offset, int maxlen, %s *p, int elements);", tn_, tn_);
    emit(0,"int     __%s_decode_array_cleanup(%s *p, int elements);", tn_, tn_);
    emit(0,"int     __%s_encoded_array_size(const %s *p, int elements);", tn_, tn_);
    emit(0,"int     __%s_clone_array(const %s *p, %s *q, int elements);", tn_, tn_, tn_);
    emit(0,"");

}

static void emit_c_struct_get_hash(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn  = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0, "static int __%s_hash_computed;", tn_);
    emit(0, "static int64_t __%s_hash;", tn_);
    emit(0, "");

    emit(0, "int64_t __%s_hash_recursive(const __zcm_hash_ptr *p)", tn_);
    emit(0, "{");
    emit(1,     "const __zcm_hash_ptr *fp;");
    emit(1,     "for (fp = p; fp != NULL; fp = fp->parent)");
    emit(2,         "if (fp->v == __%s_get_hash)", tn_);
    emit(3,              "return 0;");
    emit(0, "");
    emit(1, "__zcm_hash_ptr cp;");
    emit(1, "cp.parent =  p;");
    emit(1, "cp.v = (void*)__%s_get_hash;", tn_);
    emit(1, "(void) cp;");
    emit(0, "");
    emit(1, "int64_t hash = (int64_t)0x%016"PRIx64"LL", ls->hash);

    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);

        emit(2, " + __%s_hash_recursive(&cp)", dots_to_underscores(lm->type->lctypename));
    }
    emit(2,";");
    emit(0, "");
    emit(1, "return (hash<<1) + ((hash>>63)&1);");
    emit(0, "}");
    emit(0, "");

    emit(0, "int64_t __%s_get_hash(void)", tn_);
    emit(0, "{");
    emit(1, "if (!__%s_hash_computed) {", tn_);
    emit(2,      "__%s_hash = __%s_hash_recursive(NULL);", tn_, tn_);
    emit(2,      "__%s_hash_computed = 1;", tn_);
    emit(1,      "}");
    emit(0, "");
    emit(1, "return __%s_hash;", tn_);
    emit(0, "}");
    emit(0, "");
}

// Create an accessor for member lm, whose name is "n". For arrays,
// the dim'th dimension is accessed. E.g., dim=0 will have no
// additional brackets, dim=1 has [a], dim=2 has [a][b].
static char *make_accessor(zcm_member_t *lm, const char *n, int dim)
{
    char *tmp = (char *) malloc(128);

    if (g_ptr_array_size(lm->dimensions) == 0) {
        sprintf(tmp, "&(%s[element].%s)", n, lm->membername);
    } else {
        int pos = sprintf(tmp, "%s[element].%s", n, lm->membername);
        for (unsigned int d = 0; d < dim; d++) {
            pos += sprintf(&tmp[pos], "[%c]", d + 'a');
        }
    }
    return tmp;
}

static char *make_array_size(zcm_member_t *lm, const char *n, int dim)
{
    if (g_ptr_array_size(lm->dimensions) == 0)
        return g_strdup_printf("1");
    else {
        zcm_dimension_t *ld = (zcm_dimension_t *) g_ptr_array_index(lm->dimensions, dim);
        switch (ld->mode)
        {
        case ZCM_CONST:
            return g_strdup_printf("%s", ld->size);
        case ZCM_VAR:
            return g_strdup_printf("%s[element].%s", n, ld->size);
        }
    }
    assert(0);
    return NULL;
}

static void emit_c_array_loops_start(zcmgen_t *zcm, FILE *f, zcm_member_t *lm, const char *n, int flags)
{
    if (g_ptr_array_size(lm->dimensions) == 0)
        return;

    for (unsigned int i = 0; i < g_ptr_array_size(lm->dimensions) - 1; i++) {
        char var = 'a' + i;

        if (flags & FLAG_EMIT_MALLOCS) {
            char stars[1000];
            for (unsigned int s = 0; s < g_ptr_array_size(lm->dimensions) - 1 - i; s++) {
                stars[s] = '*';
                stars[s+1] = 0;
            }

            emit(2+i, "%s = (%s%s*) zcm_malloc(sizeof(%s%s) * %s);",
                 make_accessor(lm, n, i),
                 map_type_name(lm->type->lctypename),
                 stars,
                 map_type_name(lm->type->lctypename),
                 stars,
                 make_array_size(lm, n, i));
        }

        emit(2+i, "{ int %c;", var);
        emit(2+i, "for (%c = 0; %c < %s; %c++) {", var, var, make_array_size(lm, "p", i), var);
    }

    if (flags & FLAG_EMIT_MALLOCS) {
        emit(2 + g_ptr_array_size(lm->dimensions) - 1, "%s = (%s*) zcm_malloc(sizeof(%s) * %s);",
             make_accessor(lm, n, g_ptr_array_size(lm->dimensions) - 1),
             map_type_name(lm->type->lctypename),
             map_type_name(lm->type->lctypename),
             make_array_size(lm, n, g_ptr_array_size(lm->dimensions) - 1));
    }
}

static void emit_c_array_loops_end(zcmgen_t *zcm, FILE *f, zcm_member_t *lm, const char *n, int flags)
{
    if (g_ptr_array_size(lm->dimensions) == 0)
        return;

    for (unsigned int i = 0; i < g_ptr_array_size(lm->dimensions) - 1; i++) {
        int indent = g_ptr_array_size(lm->dimensions) - i;
        if (flags & FLAG_EMIT_FREES) {
            char *accessor =  make_accessor(lm, "p", g_ptr_array_size(lm->dimensions) - 1 - i);
            emit(indent+1, "if (%s) free(%s);", accessor, accessor);
        }
        emit(indent, "}");
        emit(indent, "}");
    }

    if (flags & FLAG_EMIT_FREES) {
        char *accessor = make_accessor(lm, "p", 0);
        emit(2, "if (%s) free(%s);", accessor, accessor);
    }
}

static void emit_c_encode_array(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int __%s_encode_array(void *buf, int offset, int maxlen, const %s *p, int elements)", tn_, tn_);
    emit(0,"{");
    emit(1,    "int pos = 0, thislen, element;");
    emit(0,"");
    emit(1,    "for (element = 0; element < elements; element++) {");
    emit(0,"");
    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);

        emit_c_array_loops_start(zcm, f, lm, "p", FLAG_NONE);

        int indent = 2+imax(0, g_ptr_array_size(lm->dimensions) - 1);
        emit(indent, "thislen = __%s_encode_array(buf, offset + pos, maxlen - pos, %s, %s);",
             dots_to_underscores (lm->type->lctypename),
             make_accessor(lm, "p", g_ptr_array_size(lm->dimensions) - 1),
             make_array_size(lm, "p", g_ptr_array_size(lm->dimensions) - 1));
        emit(indent, "if (thislen < 0) return thislen; else pos += thislen;");

        emit_c_array_loops_end(zcm, f, lm, "p", FLAG_NONE);
        emit(0,"");
    }
    emit(1,   "}");
    emit(1, "return pos;");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_encode(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int %s_encode(void *buf, int offset, int maxlen, const %s *p)", tn_, tn_);
    emit(0,"{");
    emit(1,    "int pos = 0, thislen;");
    emit(1,    "int64_t hash = __%s_get_hash();", tn_);
    emit(0,"");
    emit(1,    "thislen = __int64_t_encode_array(buf, offset + pos, maxlen - pos, &hash, 1);");
    emit(1,    "if (thislen < 0) return thislen; else pos += thislen;");
    emit(0,"");
    emit(1,    "thislen = __%s_encode_array(buf, offset + pos, maxlen - pos, p, 1);", tn_);
    emit(1,    "if (thislen < 0) return thislen; else pos += thislen;");
    emit(0,"");
    emit(1, "return pos;");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_decode_array(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int __%s_decode_array(const void *buf, int offset, int maxlen, %s *p, int elements)", tn_, tn_);
    emit(0,"{");
    emit(1,    "int pos = 0, thislen, element;");
    emit(0,"");
    emit(1,    "for (element = 0; element < elements; element++) {");
    emit(0,"");
    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);

        emit_c_array_loops_start(zcm, f, lm, "p", zcm_is_constant_size_array(lm) ? FLAG_NONE : FLAG_EMIT_MALLOCS);

        int indent = 2+imax(0, g_ptr_array_size(lm->dimensions) - 1);
        emit(indent, "thislen = __%s_decode_array(buf, offset + pos, maxlen - pos, %s, %s);",
             dots_to_underscores (lm->type->lctypename),
             make_accessor(lm, "p", g_ptr_array_size(lm->dimensions) - 1),
             make_array_size(lm, "p", g_ptr_array_size(lm->dimensions) - 1));
        emit(indent, "if (thislen < 0) return thislen; else pos += thislen;");

        emit_c_array_loops_end(zcm, f, lm, "p", FLAG_NONE);
        emit(0,"");
    }
    emit(1,   "}");
    emit(1, "return pos;");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_decode_array_cleanup(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int __%s_decode_array_cleanup(%s *p, int elements)", tn_, tn_);
    emit(0,"{");
    emit(1,    "int element;");
    emit(1,    "for (element = 0; element < elements; element++) {");
    emit(0,"");
    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);

        emit_c_array_loops_start(zcm, f, lm, "p", FLAG_NONE);

        int indent = 2+imax(0, g_ptr_array_size(lm->dimensions) - 1);
        emit(indent, "__%s_decode_array_cleanup(%s, %s);",
             dots_to_underscores (lm->type->lctypename),
             make_accessor(lm, "p", g_ptr_array_size(lm->dimensions) - 1),
             make_array_size(lm, "p", g_ptr_array_size(lm->dimensions) - 1));

        emit_c_array_loops_end(zcm, f, lm, "p", zcm_is_constant_size_array(lm) ? FLAG_NONE : FLAG_EMIT_FREES);
        emit(0,"");
    }
    emit(1,   "}");
    emit(1, "return 0;");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_decode(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int %s_decode(const void *buf, int offset, int maxlen, %s *p)", tn_, tn_);
    emit(0,"{");
    emit(1,    "int pos = 0, thislen;");
    emit(1,    "int64_t hash = __%s_get_hash();", tn_);
    emit(0,"");
    emit(1,    "int64_t this_hash;");
    emit(1,    "thislen = __int64_t_decode_array(buf, offset + pos, maxlen - pos, &this_hash, 1);");
    emit(1,    "if (thislen < 0) return thislen; else pos += thislen;");
    emit(1,    "if (this_hash != hash) return -1;");
    emit(0,"");
    emit(1,    "thislen = __%s_decode_array(buf, offset + pos, maxlen - pos, p, 1);", tn_);
    emit(1,    "if (thislen < 0) return thislen; else pos += thislen;");
    emit(0,"");
    emit(1, "return pos;");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_decode_cleanup(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int %s_decode_cleanup(%s *p)", tn_, tn_);
    emit(0,"{");
    emit(1, "return __%s_decode_array_cleanup(p, 1);", tn_);
    emit(0,"}");
    emit(0,"");
}

static void emit_c_encoded_array_size(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int __%s_encoded_array_size(const %s *p, int elements)", tn_, tn_);
    emit(0,"{");
    emit(1,"int size = 0, element;");
    emit(1,    "for (element = 0; element < elements; element++) {");
    emit(0,"");
    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(ls->members, m);

        emit_c_array_loops_start(zcm, f, lm, "p", FLAG_NONE);

        int indent = 2+imax(0, g_ptr_array_size(lm->dimensions) - 1);
        emit(indent, "size += __%s_encoded_array_size(%s, %s);",
             dots_to_underscores (lm->type->lctypename),
             make_accessor(lm, "p", g_ptr_array_size(lm->dimensions) - 1),
             make_array_size(lm, "p", g_ptr_array_size(lm->dimensions) - 1));

        emit_c_array_loops_end(zcm, f, lm, "p", FLAG_NONE);
        emit(0,"");
    }
    emit(1,"}");
    emit(1, "return size;");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_encoded_size(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int %s_encoded_size(const %s *p)", tn_, tn_);
    emit(0,"{");
    emit(1, "return 8 + __%s_encoded_array_size(p, 1);", tn_);
    emit(0,"}");
    emit(0,"");
}

static void emit_c_num_fields(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int %s_num_fields(void)", tn_);
    emit(0,"{");
    emit(1, "return %d;", g_ptr_array_size(ls->members));
    emit(0,"}");
    emit(0,"");
}

static void emit_c_struct_size(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"size_t %s_struct_size(void)", tn_);
    emit(0,"{");
    emit(1, "return sizeof(%s);", tn_);
    emit(0,"}");
    emit(0,"");
}

static inline char *str_toupper(char *s)
{
    for(char *p = s; *p; p++)
        *p = toupper(*p);
    return s;
}

static void emit_c_get_field(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int %s_get_field(const %s *p, int i, zcm_field_t *f)", tn_, tn_);
    emit(0,"{");
    emit(1,"if (0 > i || i >= %s_num_fields())", tn_);
    emit(2,"return 1;");
    emit(1,"");

    emit(1,"switch (i) {");
    emit(1,"");

    int num_fields = g_ptr_array_size(ls->members);
    for(int i = 0; i < num_fields; i++) {
        emit(2,"case %d: {", i);

        zcm_member_t *m = (zcm_member_t *)g_ptr_array_index(ls->members, i);

        const char *type_val = NULL;
        if(zcm_is_primitive_type(m->type->shortname)) {
            type_val = str_toupper(g_strdup_printf("ZCM_FIELD_%s", m->type->shortname));
        } else {
            emit(3,"/* %s */", m->type->shortname);
            type_val = "ZCM_FIELD_USER_TYPE";
        }

        emit(3,"f->name = \"%s\";", m->membername);
        emit(3,"f->type = %s;", type_val);
        emit(3,"f->typestr = \"%s\";", m->type->shortname);

        int num_dim = g_ptr_array_size(m->dimensions);
        emit(3,"f->num_dim = %d;", num_dim);

        if(num_dim != 0) {

            for(int j = 0; j < num_dim; j++) {
                zcm_dimension_t *d = (zcm_dimension_t*) g_ptr_array_index(m->dimensions, j);
                if(d->mode == ZCM_VAR)
                    emit(3,"f->dim_size[%d] = p->%s;", j, d->size);
                else
                    emit(3,"f->dim_size[%d] = %s;", j, d->size);
            }

            for(int j = 0; j < num_dim; j++) {
                zcm_dimension_t *d = (zcm_dimension_t*) g_ptr_array_index(m->dimensions, j);
                emit(3,"f->dim_is_variable[%d] = %d;", j, d->mode == ZCM_VAR);
            }

        }

        emit(3, "f->data = (void *) &p->%s;", m->membername);

        emit(3, "return 0;");
        emit(2,"}");
        emit(2,"");
    }
    emit(2,"default:");
    emit(3,"return 1;");
    emit(1,"}");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_get_type_info(zcmgen_t *zcm, FILE *f, zcm_struct_t *ls)
{
    char *tn = ls->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"const zcm_type_info_t *%s_get_type_info(void)", tn_);
    emit(0,"{");
    emit(1,"static int init = 0;");
    emit(1,"static zcm_type_info_t typeinfo;");
    emit(1,"if (!init) {");
    emit(2,"typeinfo.encode         = (zcm_encode_t) %s_encode;", tn_);
    emit(2,"typeinfo.decode         = (zcm_decode_t) %s_decode;", tn_);
    emit(2,"typeinfo.decode_cleanup = (zcm_decode_cleanup_t) %s_decode_cleanup;", tn_);
    emit(2,"typeinfo.encoded_size   = (zcm_encoded_size_t) %s_encoded_size;", tn_);
    emit(2,"typeinfo.struct_size    = (zcm_struct_size_t)  %s_struct_size;", tn_);
    emit(2,"typeinfo.num_fields     = (zcm_num_fields_t) %s_num_fields;", tn_);
    emit(2,"typeinfo.get_field      = (zcm_get_field_t) %s_get_field;", tn_);
    emit(2,"typeinfo.get_hash       = (zcm_get_hash_t) __%s_get_hash;", tn_);
    emit(1,"}");
    emit(1,"");
    emit(1,"return &typeinfo;");
    emit(0,"}");
}

static void emit_c_clone_array(zcmgen_t *zcm, FILE *f, zcm_struct_t *lr)
{
    char *tn = lr->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"int __%s_clone_array(const %s *p, %s *q, int elements)", tn_, tn_, tn_);
    emit(0,"{");
    emit(1,    "int element;");
    emit(1,    "for (element = 0; element < elements; element++) {");
    emit(0,"");
    for (unsigned int m = 0; m < g_ptr_array_size(lr->members); m++) {
        zcm_member_t *lm = (zcm_member_t *) g_ptr_array_index(lr->members, m);

        emit_c_array_loops_start(zcm, f, lm, "q", zcm_is_constant_size_array(lm) ? FLAG_NONE : FLAG_EMIT_MALLOCS);

        int indent = 2+imax(0, g_ptr_array_size(lm->dimensions) - 1);
        emit(indent, "__%s_clone_array(%s, %s, %s);",
             dots_to_underscores (lm->type->lctypename),
             make_accessor(lm, "p", g_ptr_array_size(lm->dimensions) - 1),
             make_accessor(lm, "q", g_ptr_array_size(lm->dimensions) - 1),
             make_array_size(lm, "p", g_ptr_array_size(lm->dimensions) - 1));

        emit_c_array_loops_end(zcm, f, lm, "p", FLAG_NONE);
        emit(0,"");
    }
    emit(1,   "}");
    emit(1,   "return 0;");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_copy(zcmgen_t *zcm, FILE *f, zcm_struct_t *lr)
{
    char *tn = lr->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"%s *%s_copy(const %s *p)", tn_, tn_, tn_);
    emit(0,"{");
    emit(1,    "%s *q = (%s*) malloc(sizeof(%s));", tn_, tn_, tn_);
    emit(1,    "__%s_clone_array(p, q, 1);", tn_);
    emit(1,    "return q;");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_destroy(zcmgen_t *zcm, FILE *f, zcm_struct_t *lr)
{
    char *tn = lr->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    emit(0,"void %s_destroy(%s *p)", tn_, tn_);
    emit(0,"{");
    emit(1,    "__%s_decode_array_cleanup(p, 1);", tn_);
    emit(1,    "free(p);");
    emit(0,"}");
    emit(0,"");
}

static void emit_c_struct_publish(zcmgen_t *zcm, FILE *f, zcm_struct_t *lr)
{
    char *tn = lr->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);
    fprintf(f,
            "int %s_publish(zcm_t *lc, const char *channel, const %s *p)\n"
            "{\n"
            "      int max_data_size = %s_encoded_size (p);\n"
            "      uint8_t *buf = (uint8_t*) malloc (max_data_size);\n"
            "      if (!buf) return -1;\n"
            "      int data_size = %s_encode (buf, 0, max_data_size, p);\n"
            "      if (data_size < 0) {\n"
            "          free (buf);\n"
            "          return data_size;\n"
            "      }\n"
            "      int status = zcm_publish (lc, channel, buf, data_size);\n"
            "      free (buf);\n"
            "      return status;\n"
            "}\n\n", tn_, tn_, tn_, tn_);
}


static void emit_c_struct_subscribe(zcmgen_t *zcm, FILE *f, zcm_struct_t *lr)
{
    const char *tn = lr->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);

    fprintf(f,
            "struct _%s_subscription_t {\n"
            "    %s_handler_t user_handler;\n"
            "    void *userdata;\n"
//            "    char *channel;\n"
            "    zcm_subscription_t *lc_h;\n"
            "};\n", tn_, tn_);
    fprintf(f,
            "static\n"
            "void %s_handler_stub (const zcm_recv_buf_t *rbuf,\n"
            "                            const char *channel, void *userdata)\n"
            "{\n"
            "    int status;\n"
            "    %s p;\n"
            "    memset(&p, 0, sizeof(%s));\n"
            "    status = %s_decode (rbuf->data, 0, rbuf->data_size, &p);\n"
            "    if (status < 0) {\n"
            "        fprintf (stderr, \"error %%d decoding %s!!!\\n\", status);\n"
            "        return;\n"
            "    }\n"
            "\n"
            "    %s_subscription_t *h = (%s_subscription_t*) userdata;\n"
            "    h->user_handler (rbuf, channel, &p, h->userdata);\n"
            "\n"
            "    %s_decode_cleanup (&p);\n"
            "}\n\n", tn_, tn_, tn_, tn_, tn_, tn_, tn_, tn_
        );

    fprintf(f,
            "%s_subscription_t* %s_subscribe (zcm_t *zcm,\n"
            "                    const char *channel,\n"
            "                    %s_handler_t f, void *userdata)\n"
            "{\n"
//            "    int chan_len = strlen (channel) + 1;\n"
            "    %s_subscription_t *n = (%s_subscription_t*)\n"
            "                       malloc(sizeof(%s_subscription_t));\n"
            "    n->user_handler = f;\n"
            "    n->userdata = userdata;\n"
//            "    n->channel = (char*) malloc (chan_len);\n"
//            "    memcpy (n->channel, channel, chan_len);\n"
            "    n->lc_h = zcm_subscribe (zcm, channel,\n"
            "                                 %s_handler_stub, n);\n"
            "    if (n->lc_h == NULL) {\n"
            "        fprintf (stderr,\"couldn't reg %s ZCM handler!\\n\");\n"
            "        free (n);\n"
            "        return NULL;\n"
            "    }\n"
            "    return n;\n"
            "}\n\n", tn_, tn_, tn_, tn_, tn_, tn_, tn_, tn_
        );

    fprintf(f,
            "int %s_subscription_set_queue_capacity (%s_subscription_t* subs,\n"
            "                              int num_messages)\n"
            "{\n"
            "    return zcm_subscription_set_queue_capacity (subs->lc_h, num_messages);\n"
            "}\n\n", tn_, tn_);

    fprintf(f,
            "int %s_unsubscribe(zcm_t *zcm, %s_subscription_t* hid)\n"
            "{\n"
            "    int status = zcm_unsubscribe (zcm, hid->lc_h);\n"
            "    if (0 != status) {\n"
            "        fprintf(stderr,\n"
            "           \"couldn't unsubscribe %s_handler %%p!\\n\", hid);\n"
            "        return -1;\n"
            "    }\n"
//            "    free (hid->channel);\n"
            "    free (hid);\n"
            "    return 0;\n"
            "}\n\n", tn_, tn_, tn_
        );
}

int emit_enum(zcmgen_t *zcmgen, zcm_enum_t *le)
{
    char *tn = le->enumname->lctypename;
    char *tn_ = dots_to_underscores(tn);
    char *header_name = g_strdup_printf("%s/%s.h", getopt_get_string(zcmgen->gopt, "c-hpath"), tn_);
    char *c_name      = g_strdup_printf("%s/%s.c", getopt_get_string(zcmgen->gopt, "c-cpath"), tn_);

    // ENUM header file
    if (zcm_needs_generation(zcmgen, le->zcmfile, header_name)) {
        FILE *f = fopen(header_name, "w");
        if (f == NULL)
            return -1;

        emit_header_top(zcmgen, f, tn_);

        char *tn_upper = g_ascii_strup (tn_, strlen (tn_));

        ///////////////////////////////////////////////////////////////////
        // the enum declaration itself
        emit(0, "enum _%s {", tn_);
        for (unsigned int i = 0; i < g_ptr_array_size(le->values); i++) {
            zcm_enum_value_t *lev = (zcm_enum_value_t *) g_ptr_array_index(le->values, i);
            emit(1," %s_%s = %d%s",
                    tn_upper,
                    lev->valuename,
                    lev->value, i==(g_ptr_array_size(le->values)-1) ? "" : ",");
        }

        free (tn_upper);

        emit(0, "};");
        emit(0, "");

        emit(0, "typedef enum _%s %s;", tn_, tn_);
        emit(0, "");

        emit(0, "const char * %s_name(%s val);", tn_, tn_);
        emit(0, "");

        ///////////////////////////////////////////////////////////////////

        emit(0, "static inline int64_t __%s_hash_recursive(const __zcm_hash_ptr *p)", tn_);
        emit(0, "{");
        emit(1,    "return 0x%016"PRIx64"LL;", le->hash);
        emit(0, "}");
        emit(0, "");

        emit(0, "static inline int64_t __%s_get_hash()", tn_);
        emit(0, "{");
        emit(1,    "return 0x%016"PRIx64"LL;", le->hash);
        emit(0, "}");
        emit(0, "");

        // enums are always "ints", but "ints" are not always int32_t. We
        // always store an enum as an int32_t, however. Consequently, we
        // jump through some hoops here in order to allow the compiler to
        // convert from an int32_t to whatever the native size of "int"
        // is.
        emit(0, "static inline int __%s_encode_array(void *_buf, int offset, int maxlen, const %s *p, int elements)", tn_, tn_);
        emit(0, "{");
        emit(1,    "int pos = 0, thislen, element;");
        emit(1,     "for (element = 0; element < elements; element++) {");
        emit(2,         "int32_t v = (int32_t) p[element];");
        emit(2,         "thislen = __int32_t_encode_array(_buf, offset + pos, maxlen - pos, &v, 1);");
        emit(2,         "if (thislen < 0) return thislen; else pos += thislen;");
        emit(1,     "}");
        emit(1, "return thislen;");
        emit(0, "}");
        emit(0, "");

        emit(0,"static inline int %s_encode(void *buf, int offset, int maxlen, const %s *p)", tn_, tn_);
        emit(0,"{");
        emit(1,    "int pos = 0, thislen;");
        emit(1,    "int64_t hash = 0x%016"PRIx64"LL;", le->hash);
        emit(0,"");
        emit(1,    "thislen = __int64_t_encode_array(buf, offset + pos, maxlen - pos, &hash, 1);");
        emit(1,    "if (thislen < 0) return thislen; else pos += thislen;");
        emit(0,"");
        emit(1,    "thislen = __%s_encode_array(buf, offset + pos, maxlen - pos, p, 1);", tn_);
        emit(1,    "if (thislen < 0) return thislen; else pos += thislen;");
        emit(0,"");
        emit(1, "return pos;");
        emit(0,"}");
        emit(0,"");

        emit(0, "static inline int __%s_decode_array(const void *_buf, int offset, int maxlen, %s *p, int elements)", tn_, tn_);
        emit(0, "{");
        emit(1,    "int pos = 0, thislen, element;");
        emit(1,     "for (element = 0; element < elements; element++) {");
        emit(2,         "int32_t v;");
        emit(2,         "thislen = __int32_t_decode_array(_buf, offset + pos, maxlen - pos, &v, 1);");
        emit(2,         "if (thislen < 0) return thislen; else pos += thislen;");
        emit(2,         "p[element] = (%s) v;", tn_);
        emit(1,     "}");
        emit(1, "return thislen;");
        emit(0, "}");
        emit(0, "");

        emit(0, "static inline int __%s_clone_array(const %s *p, %s *q, int elements)", tn_, tn_, tn_);
        emit(0, "{");
        emit(1,    "memcpy(q, p, elements * sizeof(%s));", tn_);
        emit(1,    "return 0;");
        emit(0, "}");
        emit(0, "");

        emit(0,"static inline int %s_decode(const void *buf, int offset, int maxlen, %s *p)", tn_, tn_);
        emit(0,"{");
        emit(1,    "int pos = 0, thislen;");
        emit(1,    "int64_t hash = 0x%016"PRIx64"LL;", le->hash);
        emit(0,"");
        emit(1,    "int64_t this_hash;");
        emit(1,    "thislen = __int64_t_decode_array(buf, offset + pos, maxlen - pos, &this_hash, 1);");
        emit(1,    "if (thislen < 0) return thislen; else pos += thislen;");
        emit(1,    "if (this_hash != hash) return -1;");
        emit(0,"");
        emit(1,    "thislen = __%s_decode_array(buf, offset + pos, maxlen - pos, p, 1);", tn_);
        emit(1,    "if (thislen < 0) return thislen; else pos += thislen;");
        emit(0,"");
        emit(1,   "return pos;");
        emit(0,"}");
        emit(0,"");

        emit(0, "static inline int __%s_decode_array_cleanup(%s *in, int elements)", tn_, tn_);
        emit(0, "{");
        emit(1,    "return 0;");
        emit(0, "}");
        emit(0, "");

        emit(0,"static inline int %s_decode_cleanup(%s *p)", tn_, tn_);
        emit(0,"{");
        emit(1,    "return 0;");
        emit(0,"}");
        emit(0,"");

        emit(0, "static inline int __%s_encoded_array_size(const %s *p, int elements)", tn_, tn_);
        emit(0, "{");
        emit(1,    "return __int32_t_encoded_array_size((const int32_t*)p, elements);");
        emit(0, "}");
        emit(0, "");

        emit(0, "static inline int %s_encoded_size(const %s *in)", tn_, tn_);
        emit(0, "{");
        emit(1,    "return int32_t_encoded_size((const int32_t*)in);");
        emit(0, "}");
        emit(0, "");

        emit_header_bottom(zcmgen, f);
        fclose(f);
    }

    // ENUM C file
    if (zcm_needs_generation(zcmgen, le->zcmfile, c_name)) {
        char *tn_upper = g_ascii_strup (tn_, strlen (tn_));

        FILE *f = fopen(c_name, "w");
        emit_auto_generated_warning(f);

        fprintf(f, "#include \"%s%s%s.h\"\n",
                getopt_get_string(zcmgen->gopt, "cinclude"),
                strlen(getopt_get_string(zcmgen->gopt, "cinclude"))>0 ? "/" : "",
                tn_);

        emit(0, "const char * %s_name(%s val)", tn_, tn_);
        emit(0, "{");
        emit(1,     "switch (val) {");
        for (unsigned int i = 0; i < g_ptr_array_size(le->values); i++) {
            zcm_enum_value_t *lev = (zcm_enum_value_t *) g_ptr_array_index(le->values, i);
            emit(2, "case %s_%s:", tn_upper, lev->valuename);
            emit(3,     "return \"%s\";", lev->valuename);
        }
        emit(2,         "default:");
        emit(3,             "return NULL;");
        emit(1,     "}");
        emit(0, "}");
        fclose(f);

        free (tn_upper);
    }

    return 0;
}

int emit_struct(zcmgen_t *zcmgen, zcm_struct_t *lr)
{
    char *tn = lr->structname->lctypename;
    char *tn_ = dots_to_underscores(tn);
    char *header_name = g_strdup_printf("%s/%s.h", getopt_get_string(zcmgen->gopt, "c-hpath"), tn_);
    char *c_name      = g_strdup_printf("%s/%s.c", getopt_get_string(zcmgen->gopt, "c-cpath"), tn_);

    if (zcm_needs_generation(zcmgen, lr->zcmfile, header_name)) {
        FILE *f = fopen(header_name, "w");
        if (f == NULL)
            return -1;

        emit_header_top(zcmgen, f, tn_);
        emit_header_struct(zcmgen, f, lr);
        emit_header_prototypes(zcmgen, f, lr);

        emit_header_bottom(zcmgen, f);
        fclose(f);
    }

    // STRUCT C file
    if (zcm_needs_generation(zcmgen, lr->zcmfile, c_name)) {
        FILE *f = fopen(c_name, "w");
        if (f == NULL)
            return -1;

        emit_auto_generated_warning(f);
        fprintf(f, "#include <string.h>\n");
        fprintf(f, "#include \"%s%s%s.h\"\n",
                getopt_get_string(zcmgen->gopt, "cinclude"),
                strlen(getopt_get_string(zcmgen->gopt, "cinclude"))>0 ? "/" : "",
                tn_);
        fprintf(f, "\n");

        emit_c_struct_get_hash(zcmgen, f, lr);
        emit_c_encode_array(zcmgen, f, lr);
        emit_c_encode(zcmgen, f, lr);
        emit_c_encoded_array_size(zcmgen, f, lr);
        emit_c_encoded_size(zcmgen, f, lr);

        if(getopt_get_bool(zcmgen->gopt, "c-typeinfo")) {
            emit_c_struct_size(zcmgen, f, lr);
            emit_c_num_fields(zcmgen, f, lr);
            emit_c_get_field(zcmgen, f, lr);
            emit_c_get_type_info(zcmgen, f, lr);
        }

        emit_c_decode_array(zcmgen, f, lr);
        emit_c_decode_array_cleanup(zcmgen, f, lr);
        emit_c_decode(zcmgen, f, lr);
        emit_c_decode_cleanup(zcmgen, f, lr);

        emit_c_clone_array(zcmgen, f, lr);
        emit_c_copy(zcmgen, f, lr);
        emit_c_destroy(zcmgen, f, lr);

        if(!getopt_get_bool(zcmgen->gopt, "c-no-pubsub")) {
            emit_c_struct_publish(zcmgen, f, lr );
            emit_c_struct_subscribe(zcmgen, f, lr );
        }

        fclose(f);
    }

    return 0;
}

int emit_c(zcmgen_t *zcmgen)
{
    ////////////////////////////////////////////////////////////
    // ENUMS
    for (unsigned int i = 0; i < g_ptr_array_size(zcmgen->enums); i++) {

        zcm_enum_t *le = (zcm_enum_t *) g_ptr_array_index(zcmgen->enums, i);
        if (emit_enum(zcmgen, le))
            return -1;
    }

    ////////////////////////////////////////////////////////////
    // STRUCTS
    for (unsigned int i = 0; i < g_ptr_array_size(zcmgen->structs); i++) {
        zcm_struct_t *lr = (zcm_struct_t *) g_ptr_array_index(zcmgen->structs, i);

        if (emit_struct(zcmgen, lr))
            return -1;
    }

    return 0;
}
