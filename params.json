{"name":"Zcm","tagline":"Zero Communications and Marshalling","body":"#Zero Communications and Marshalling (ZCM)\r\n\r\nZCM is a micro-framework for mesaage-passing and data-marshalling, designed originally\r\nfor robotics systems where high-bandwidth and low latency are critical and the variance in\r\ncompute platforms is large.\r\n\r\nZCM provides a publish/subscribe message-passing model and automatic marshalling/unmarshalling\r\ncode generation with bindings for a variety of programming languages. This message-type design\r\nrespects language-specific coding idioms insofar as possible.\r\n\r\nZCM is transport-agnostic. There is no single built-in transport backend. Every transport is\r\nfirst-class. This is achieved by defining strict blocking and non-blocking transport APIs. As\r\nlong as a transport implementation conforms to this API, it should work flawlessly with ZCM.\r\nThis design allows ZCM to work well on anything from a high-end posix-based compute cluster\r\nto a low-end real-time embedded-system with no operating system.\r\n\r\nZCM is a derivation of the LCM project created in 2006 by the MIT DARPA Urban Challenge\r\nteam. The core message-type system, publish/subscribe APIs, and basic tools are ported\r\ndirectly from LCM and remain about 99% compatible. While there are a handful of subtle\r\ndifferences between the two, the core distinguishing feature is ZCM's transport\r\nagnosticism. LCM is designed competely around UDP Multicast. This trasport makes a lot\r\nof sense for LAN connected compute clusters (such the original 2006 MIT DGC Vechicle).\r\nHowever, there are many other applications that are interesting targets for ZCM messaging.\r\nThese include, local system messaging (IPC), multi-threaded messaging (in-procees),\r\nembedded-system periphials (UART, I2C, etc), and web applications (Web Sockets).\r\nBy refusing to make hard assumptions about the transport layer, ZCM opens the door\r\nto a wide set of use-cases that were never possible or practical with LCM.\r\n\r\n# Quick Links\r\n\r\n* [ZCM downloads]()\r\n* [Website and documentation]()\r\n\r\n# Features\r\n\r\n* Type-safe message marshalling\r\n* A useful suite of tools for logging, log-playback, real-time message inspection (spy)\r\n* A wide set of built-in transports incl. UDP Multicast, IPC, In-Process, and Serial\r\n* An easy-to-use and well-defined interface for building custom transports\r\n* Strong support for embedded uses. The core embedded code is compliant C89.\r\n* Only one true dependency: A reasonably modern C++11 compiler for the non-embedded code.\r\n* Some of the transports are built-on top of ZeroMQ, but this dependency is opt-in.\r\n\r\n## Supported platforms and languages\r\n\r\n* Platforms:\r\n  * GNU/Linux\r\n  * Web browsers supporting the Websocket API\r\n  * Any C89 capable embedded system\r\n* Languages\r\n  * C89 or greater\r\n  * C++\r\n  * Java\r\n  * MATLAB (using Java)\r\n  * Python\r\n  * NodeJS and Client-side Javascript\r\n\r\n## Roadmap\r\n\r\n* Port LCM UDP Multicast to achieve full backwards compatibility\r\n\r\n* Platform Support:\r\n  * OS X\r\n  * Windows\r\n  * Any POSIX-1.2001 system (e.g., Cygwin, Solaris, BSD, etc.)\r\n\r\n* Consider porting the rest of the LCM languages\r\n  * C#\r\n  * Lua\r\n\r\n* Explore alternative messaging types using ZCM Types, such as those found in ZeroMQ\r\n\r\n## Subtle differences to LCM\r\n\r\n* TODO\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}