<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>ZCM Tutorial</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>ZCM</h1>
        <p>Zero Communications and Marshalling</p>

        <p class="view"><a href="https://github.com/ZeroCM/zcm">View the Project on GitHub <small>ZeroCM/zcm</small></a></p>


        <ul>
          <!-- <li><a href="https://github.com/ZeroCM/zcm/zipball/master">Download <strong>ZIP File</strong></a></li> -->
          <!-- <li><a href="https://github.com/ZeroCM/zcm/tarball/master">Download <strong>TAR Ball</strong></a></li> -->
          <li><a href="https://github.com/ZeroCM/zcm">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="zcm-tutorial" class="anchor" href="#zcm-tutorial" aria-hidden="true"><span class="octicon octicon-link"></span></a>ZCM Tutorial</h1>

<p>We believe the best way to learn new things is to just dive in and start making mistakes.
It's only by making those early mistakes that one truely can understand the folly of one's
ways and to grow as a result. So, without further ado, let's get started.</p>

<h2>
<a id="basic-types" class="anchor" href="#basic-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic Types</h2>

<p>To understand ZCM, we must start by discussing it's message type-system. Every message sent inside
ZCM can be tied back to some message specification. Let's explore this with a simple, yet practical example.
Imagine that we have a typical rotation sensor such as an IMU or Gyro. Our sensor produces
yaw, pitch, and roll measurements as well as a few flags describing it's mode of operation. If we were
programming in just C code, we might design a struct type as follows:
<pre>
struct rotation_t {
    double yaw;
    double pitch;
    double roll;
    int   flags;
};
</pre>
</p>

<p>In ZCM, we aim to retain this rich data structuring and layout while still being able to do
powerfull message-passing in numerous different programming languages. To do this, we use a
programming-language-agnostic type specification language. Fortunately for our example above,
it is very similair to C struct syntax. Here it is:
<pre>
struct rotation_t {
    double yaw;
    double pitch;
    double roll;
    int32_t flags;
};
</pre>
</p>

<p>The ZCM type is almost an exact copy. The key difference here is that in C 'int' is not
strictly defined. An 'int' can be a different size depending on the machine the software
runs on. Because a ZCM Type is a binary data-exchange format, it needs to have rigourously
defined types that mean the same thing on each machine. Here's a brief table of the default
built-in types:
</p>

<table>
<tr><td>int8_t</td><td>8-bit signed integer</td></tr>
<tr><td>int16_t</td><td>16-bit signed integer</td></tr>
<tr><td>int32_t</td><td>32-bit signed integer</td></tr>
<tr><td>int64_t</td><td>64-bit signed integer</td></tr>
<tr><td>float</td><td>32-bit IEEE floating point value</td></tr>
<tr><td>double</td><td>64-bit IEEE floating point value</td></tr>
<tr><td>string</td><td>UTF-8 string</td></tr>
<tr><td>boolean</td><td>true/false logical value</td></tr>
<tr><td>byte</td><td>8-bit value</td></tr>
</table>

<p>Believe it or not, this is all the basic knowledge needed to get started. Let's dive into
code, and build a working program using ZCM!</p>

<h2>
<a id="hello-world" class="anchor" href="#hello-world" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World</h2>

<p>Let's build a canonical Hello World message-passing program on top of ZCM. For this we
will need two programs. One program will create and <i>publish</i> new messages and the
other program will <i>subscribe</i> to and receive those messages.</p>

<h3>
<a id="hello-world-types" class="anchor" href="#hello-world-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World Types</h3>

<p>First, let's create a new zcm type in the file <i>msg_t.zcm</i>
<pre>
struct msg_t {
    string str;
}
</pre>
</p>

<p> We can now use the <i>zcm-gen</i> tool to convert this type specification into bindings
for many different programming languages. We will be using C code for this example, so run:
<pre>zcm-gen -c msg_t.zcm</pre>
</p>

<p>This command will produce two new files in the current directory (msg_t.h and msg_t.c).
Feel free to browse these files for a moment to get a rough idea of how zcm-gen works. Notice
that zcm-gen has converted the <i>string</i> to a native C type. We always try to use the
native data types in each programming langauge, so the programming experience doesn't feel foreign.
<pre>
typedef struct _msg_t msg_t;
struct _msg_t
{
     char*      str;
};
</pre>
</p>

<h3>
<a id="hello-world-publish" class="anchor" href="#hello-world-publish" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World Publish</h3>

<p>For most simple programs, the only include needed is the basic zcm, but we also need to include our msg_t header
<pre>
#include &ltzcm/zcm.h&gt
#include &ltmsg_t.h&gt
</pre>
</p>

<p>In the main function we have to create a zcm instance that will manage the communications. Here, you decide which
transport protocol to use and provide an appropriate url. For this example, we'll use Inter-process Communication (IPC):
<pre>
zcm_t *zcm = zcm_create("ipc");
</pre>

<p>Finally, we simply construct a msg_t and then publish it repeatedly:
<pre>
msg_t msg;
msg.str = (char*)"Hello, World!";

while (1) {
    msg_t_publish(zcm, "HELLO_WORLD", &amp;msg);
    usleep(1000000); /* sleep for a second */
}
</pre>
</p>

<p>And that's it! Here's the full program (publish.c):
<pre>
#include &lt;unistd.h&gt;
#include &lt;zcm/zcm.h&gt;
#include &lt;msg_t.h&gt;

int main(int argc, char *argv[])
{
    zcm_t *zcm = zcm_create("ipc");

    msg_t msg;
    msg.str = (char*)"Hello, World!";

    while (1) {
        msg_t_publish(zcm, "HELLO_WORLD", &amp;msg);
        usleep(1000000); /* sleep for a second */
    }

    zcm_destroy(zcm);
    return 0;
}

</pre>
</p>

<p>Building and running:
<pre>
cc -o publish -I. publish.c msg_t.c -lzcm
./publish
</pre>

<p>If you have the java ZCM tools installed, you should be able to run zcm-spy and
see the published messages now!
<pre>
zcm-spy -l ipc
</pre>

<h3>
<a id="hello-world-subscribe" class="anchor" href="#hello-world-subscribe" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World Subscribe</h3>

<p> Let's build a program to recieve those messages. We'll start off the same as before
by adding the headers and creating a new zcm_t* instance. Then, we need to <i>subscribe</i>
to the particular channel. But, first we need to create a callback function to handle all the
received messages:
<pre>
void callback_handler(const zcm_recv_buf_t *rbuf, const char *channel, const msg_t *msg, void *usr)
{
    printf("Received a message on channel '%s'\n", channel);
    printf("msg->str = '%s'\n", msg->str);
    printf("\n");
}
</pre>
</p>

<p> Now, in the main() function, we need to register this callback by subscribing:
<pre>
msg_t_subscribe(zcm, "HELLO_WORLD", callback_handler, NULL);
</pre>
</p>

<p> Finally, in order to dispatch messages to the callbacks, ZCM needs a thread. So, we
call into zcm to tell it to consume the current thread and use it for dispatching any
incomming messages (zcm_become doesn't normally return):
<pre>
zcm_become(zcm);
</pre>
<pr>

<p>And that's it! Here's the full program (subscribe.c):
<pre>
#include &lt;stdio.h&gt;
#include &lt;zcm/zcm.h&gt;
#include &lt;msg_t.h&gt;

void callback_handler(const zcm_recv_buf_t *rbuf, const char *channel, const msg_t *msg, void *usr)
{
    printf("Received a message on channel '%s'\n", channel);
    printf("msg->str = '%s'\n", msg->str);
    printf("\n");
}

int main(int argc, char *argv[])
{
    zcm_t *zcm = zcm_create("ipc");
    msg_t_subscribe(zcm, "HELLO_WORLD", callback_handler, NULL);

    zcm_become(zcm);

    zcm_destroy(zcm);
    return 0;
}
</pre>
</p>

<p>Building and running:
<pre>
cc -o subscribe -I. subscribe.c msg_t.c -lzcm
./subscribe
</pre>

<p> Now, with both ./publish and ./subscribe running, you should successfully
see a stream of data in the subscribe window!
<pre>
Received a message on channel 'HELLO_WORLD'
msg->str = 'Hello, World!'
</pre>
</p>

<h2>
<a id="type-safety" class="anchor" href="#type-safety" aria-hidden="true"><span class="octicon octicon-link"></span></a>Type Safety</h3>

<p> Another super useful feature of the ZCM type system is its type checking capabilities.
These type checks make it hard to accidentally change message types without updating
programs that rely on them. For a mission critical system such as a robotics system, this
is a crutial feature.
</p>

<p> Let's explore this by example. Let's revist our msg_t type and add a new field, changing
it to look as follows:
<pre>
struct msg_t {
    boolean can_frobinate;
    string str;
};
</pre>
</p>

<p>Adding this new field has changed the type's encoding and any existing program not aware
of the change might decode the wrong bytes! Let's regenerate and look at the new C bindings:
<pre>
zcm-gen -c msg_t.zcm && cat msg_t.h
/* ... code removed ... */
typedef struct _msg_t msg_t;
struct _msg_t
{
    int8_t     can_frobinate;
    char*      str;
};
/* ... code removed ... */
</pre>
</p>

<p>Clearly, it was bad engineering to evolve this message like this, but these things can
happen accidentally and can result in tricky bugs to track down, especially if the changes
are more subtle. To show how ZCM detects this issue, let's change publish.c to use the new
type:
<pre> msg.can_frobinate = 0; </pre>
</p>

<p> If we rebuild the publisher and try running it with the old subscriber, the subscribe
reports:
<pre>
error -1 decoding msg_t!!!
</pre>
</p>

<p>The decoder was able to successfully determine a mismatch, and correctly rejected the
incoming data. How does this work? Well, internally ZCM computes a hash code for each
type based on the individual field types and their orderings. If any of these types
change, get re-ordered, etc. existing programs will be capable of detecting this mismatch
and they will refuse to decode the faulty data!</p>


      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/ZeroCM">ZeroCM</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>

  </body>
</html>
