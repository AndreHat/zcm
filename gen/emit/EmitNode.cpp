#include <iostream>
#include <string>
#include "Common.hpp"
#include "GetOpt.hpp"
#include "util/StringUtil.hpp"
#include "ZCMGen.hpp"
#include "Emitter.hpp"

using namespace std;

// RRR (Bendes) Handle packages

void setupOptionsNode(GetOpt& gopt)
{
    gopt.addString(0, "npath", ".", "Location for zcmtypes.js file");
}

static string dimSizeAccessor(const string& dimSize)
{
    assert(dimSize.size() > 0);
    char c = dimSize[0];
    if ('0' <= c && c <= '9')
        return dimSize;
    else
        return "this." + dimSize;
}

static string getWriterFunc(const string& type)
{
    if (type == "double") {
        return "writeDouble";
    } else if (type == "float") {
        return "writeFloat";
    } else if (type == "int64_t") {
        return "write64";
    } else if (type == "int32_t") {
        return "write32";
    } else if (type == "int16_t") {
        return "write16";
    } else if (type == "int8_t" || type == "byte") {
        return "write8";
    } else if (type == "boolean") {
         return "writeBoolean";
    } else if (type == "string") {
         return "writeString";
    } else {
        return "";
    }
}

struct EmitModule : public Emitter
{
    ZCMGen& zcm;

    EmitModule(ZCMGen& zcm, const string& fname):
        Emitter(fname), zcm(zcm) {}

    void emitAutoGeneratedWarning()
    {
        emit(0, "/** THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY");
        emit(0, " * BY HAND!!");
        emit(0, " *");
        emit(0, " * Note that recursive types and const data members are");
        emit(0, " * not currently supported");
        emit(0, " *");
        emit(0, " * Generated by zcm-gen");
        emit(0, " **/");
        emit(0, "");
    }

    void emitHeader()
    {
        emitAutoGeneratedWarning();

        emit(0, "var ref = require('ref');");
        emit(0, "var bigint = require('big-integer');");
        emit(0, "");
        emit(0, "var UINT64_MAX = bigint('ffffffffffffffff', 16);");
        emit(0, "function rotateLeftOne(val)");
        emit(0, "{");
        emit(0, "    return val.shiftLeft(1).and(UINT64_MAX).add("
                           "val.shiftRight(63).and(1))");
        emit(0, "}");
        emit(0, "");
        emit(0, "function createReader(data)");
        emit(0, "{");
        emit(0, "    var buf = data;");
        emit(0, "    var offset = 0;");
        emit(0, "    var methods = {");
        emit(0, "        readDouble: function() {");
        emit(0, "            var ret = buf.readDoubleBE(offset);");
        emit(0, "            offset += 8;");
        emit(0, "            return ret;");
        emit(0, "        },");
        emit(0, "        readFloat: function() {");
        emit(0, "            var ret = buf.readFloatBE(offset);");
        emit(0, "            offset += 4;");
        emit(0, "            return ret;");
        emit(0, "        },");
        emit(0, "        read64: function() {");
        emit(0, "            var ret = bigint(ref.readInt64BE(buf, offset));");
        emit(0, "            offset += 8;");
        emit(0, "            return ret;");
        emit(0, "        },");
        emit(0, "        read32: function() {");
        emit(0, "            var ret = buf.readInt32BE(offset);");
        emit(0, "            offset += 4;");
        emit(0, "            return ret;");
        emit(0, "        },");
        emit(0, "        read16: function() {");
        emit(0, "            var ret = buf.readInt16BE(offset);");
        emit(0, "            offset += 2;");
        emit(0, "            return ret;");
        emit(0, "        },");
        emit(0, "        read8: function() {");
        emit(0, "            var ret = buf.readInt8(offset);");
        emit(0, "            offset += 1;");
        emit(0, "            return ret;");
        emit(0, "        },");
        emit(0, "        readBoolean: function() {");
        emit(0, "            var ret = buf.readInt8(offset);");
        emit(0, "            offset += 1;");
        emit(0, "            return ret != 0;");
        emit(0, "        },");
        emit(0, "        readString: function() {");
        emit(0, "            var len = methods.read32();");
        emit(0, "            var ret = ref.readCString(buf, offset);");
        emit(0, "            offset += len;");
        emit(0, "            return ret;");
        emit(0, "        },");
        emit(0, "    };");
        emit(0, "    return methods;");
        emit(0, "}");
        emit(0, "");
        emit(0, "function createWriter(size)");
        emit(0, "{");
        emit(0, "    var buf = new Buffer(size);");
        emit(0, "    var offset = 0;");
        emit(0, "    var methods = {");
        emit(0, "        writeDouble: function(value) {");
        emit(0, "            buf.writeDoubleBE(value, offset);");
        emit(0, "            offset += 8;");
        emit(0, "        },");
        emit(0, "        writeFloat: function(value) {");
        emit(0, "            buf.writeFloatBE(value, offset);");
        emit(0, "            offset += 4;");
        emit(0, "        },");
        emit(0, "        write64: function(value) {");
        emit(0, "            ref.writeInt64BE(buf, offset, bigint.isInstance(value) ?");
        emit(0, "                                          value.toString() : value);");
        emit(0, "            offset += 8;");
        emit(0, "        },");
        emit(0, "        writeU64: function(value) {");
        emit(0, "            ref.writeUInt64BE(buf, offset, bigint.isInstance(value) ?");
        emit(0, "                                           value.toString() : value);");
        emit(0, "            offset += 8;");
        emit(0, "        },");
        emit(0, "        write32: function(value) {");
        emit(0, "            buf.writeInt32BE(value, offset);");
        emit(0, "            offset += 4;");
        emit(0, "        },");
        emit(0, "        write16: function(value) {");
        emit(0, "            buf.writeInt16BE(value, offset);");
        emit(0, "            offset += 2;");
        emit(0, "        },");
        emit(0, "        write8: function(value) {");
        emit(0, "            buf.writeInt8(value, offset);");
        emit(0, "            offset += 1;");
        emit(0, "        },");
        emit(0, "        writeBoolean: function(value) {");
        emit(0, "            buf.writeInt8(value, offset);");
        emit(0, "            offset += 1;");
        emit(0, "        },");
        emit(0, "        writeString: function(value) {");
        emit(0, "            methods.write32(value.length+1);");
        emit(0, "            ref.writeCString(buf, offset, value);");
        emit(0, "            offset += value.length+1;");
        emit(0, "        },");
        emit(0, "        writeArray: function(arr, size, writeValFunc) {");
        emit(0, "            for (var i = 0; i < size; ++i)");
        emit(0, "                writeValFunc(arr[i]);");
        emit(0, "        },");
        emit(0, "        getBuffer: function() {");
        emit(0, "            return buf;");
        emit(0, "        },");
        emit(0, "    };");
        emit(0, "    return methods;");
        emit(0, "}");
        emit(0, "");
    }

    void emitEncodeSingleMember(const ZCMMember& lm, const string& accessor_, int indent)
    {
        auto *accessor = accessor_.c_str();
        auto& tn = lm.type.shortname;
        auto writerFunc = getWriterFunc(tn);

        if (writerFunc != "") {
            emit(indent, "W.%s(%s);", writerFunc.c_str(), accessor);
        } else {
            emit(indent, "%s_encode_one(%s, W)", tn.c_str(), accessor);
        }
    }

    void emitEncodeListMember(const ZCMMember& lm, const string& accessor_, int indent,
                              const string& len_, int fixedLen)
    {
        auto& tn = lm.type.fullname;
        auto *accessor = accessor_.c_str();
        auto *len = len_.c_str();

        auto writerFunc = getWriterFunc(tn);

        if (writerFunc != "") {
            if (fixedLen) {
                emit(indent, "W.writeArray(%s, %s, W.%s);", accessor, len, writerFunc.c_str());
            } else {
                emit(indent, "W.writeArray(%s, msg.%s, W.%s);",
                             accessor, len, writerFunc.c_str());
            }
        } else {
            fprintf(stderr, "Unable to encode list of type: %s\n", tn.c_str());
            assert(0);
        }
    }

    void emitEncodeOne(const ZCMStruct& ls)
    {
        auto* sn = ls.structname.shortname.c_str();
        emit(0, "%s_encode_one = function(msg, W)", sn);
        emit(0, "{");
        if (ls.members.size() == 0) {
            emit(0, "}");
            return;
        }

        for (auto& lm : ls.members) {
            if (lm.dimensions.size() == 0) {
                emitEncodeSingleMember(lm, "msg." + lm.membername, 1);
            } else {
                string accessor = "msg." + lm.membername;
                size_t n;
                for (n = 0; n < lm.dimensions.size() - 1; n++) {
                    auto& dim = lm.dimensions[n];
                    accessor += "[i" + to_string(n) + "]";
                    if (dim.mode == ZCM_CONST) {
                        emit(1 + n, "for (var i%d = 0; i%d < %s; ++i%d) {",
                                    n, n, dim.size.c_str(), n);
                    } else {
                        emit(1 + n, "for (var i%d = 0; i%d < msg.%s; ++i%d) {",
                                    n, n, dim.size.c_str(), n);
                    }
                }

                // last dimension.
                auto& lastDim = lm.dimensions[lm.dimensions.size() - 1];
                bool lastDimFixedLen = (lastDim.mode == ZCM_CONST);

                if (ZCMGen::isPrimitiveType(lm.type.fullname)) {
                    emitEncodeListMember(lm, accessor, n + 1, lastDim.size, lastDimFixedLen);
                } else {
                    if (lastDimFixedLen) {
                        emit(n + 1, "for (var i%d = 0; i%d < %s; ++i%d) {",
                                    n, n, lastDim.size.c_str(), n);
                    } else {
                        emit(n + 1, "for (var i%d = 0; i%d < msg.%s; ++i%d) {",
                                    n, n, lastDim.size.c_str(), n);
                    }
                    accessor += "[i" + to_string(n) + "]";
                    emitEncodeSingleMember(lm, accessor, n + 2);
                    emit(n + 1, "}");
                }
                for (int i = n - 1; i >= 0; --i) {
                    emit(i + 1, "}");
                }
            }
        }
        emit(0, "}");
    }

    void emitEncode(const ZCMStruct& ls)
    {
        auto* sn = ls.structname.shortname.c_str();
        emit(0, "%s.prototype.encode = function()", sn);
        emit(0, "{");
        emit(0, "    var size = this.encodedSize();");
        emit(0, "    var W = createWriter(size);");
        emit(0, "    W.writeU64(%s.__get_hash_recursive());", sn);
        emit(0, "    %s_encode_one(this, W);", sn);
        emit(0, "    return W.getBuffer();");
        emit(0, "};");
    }

    void emitEncodedSize(const ZCMStruct& ls)
    {
        auto *sn = ls.structname.shortname.c_str();
        emit(0, "%s.prototype.encodedSize = function()", sn);
        emit(0, "{");
        emit(1, "var size = 8;");
        emit(1, "var tmp = 1;");
        for (auto& lm : ls.members) {
            auto& mtn = lm.type.fullname;
            auto& mn = lm.membername;

            if (!ZCMGen::isPrimitiveType(mtn)) {
                emit(1, "size += this.%s.encodedSize();", mn.c_str());
            } else if (mtn != "string") {
                int ndims = (int)lm.dimensions.size();
                if (ndims == 0) {
                    emit(1, "size += %d; \t//%s",
                                 ZCMGen::getPrimitiveTypeSize(mtn), mn.c_str());
                } else {
                    emit(1, "tmp = 1;");
                    for (int i = 0; i < ndims; ++i) {
                        auto sz = dimSizeAccessor(lm.dimensions[i].size);
                        emit(1, "tmp *= %s;", sz.c_str());
                    }
                    emit(1, "size += tmp * %d; \t//%s",
                                 ZCMGen::getPrimitiveTypeSize(mtn), mn.c_str());
                }
            } else {
                int ndims = (int)lm.dimensions.size();
                if (ndims == 0) {
                    // The +1 and +4 below are to account for the null character
                    // and the writing of the length respectively
                    emit(1, "size += this.%s.length + 1 + 4;", mn.c_str());
                } else {
                    emit(1, "for (var i = 0; i < this.%s.length; ++i) {", mn.c_str());
                    emit(1 + 1, "size += this.%s[i].length + 1 + 4;", mn.c_str());
                    emit(1, "}");
                }
            }
        }
        emit(1, "return size;");
        emit(0, "};");
    }

    void emitDecodePrimType(int indent, const string& lvalue, const string& type)
    {
        if (type == "double") {
            emit(indent, "%s = R.readDouble();", lvalue.c_str());
        } else if (type == "float") {
            emit(indent, "%s = R.readFloat();", lvalue.c_str());
        } else if (type == "int64_t") {
            emit(indent, "%s = R.read64().toString();", lvalue.c_str());
        } else if (type == "int32_t") {
            emit(indent, "%s = R.read32();", lvalue.c_str());
        } else if (type == "int16_t") {
            emit(indent, "%s = R.read16();", lvalue.c_str());
        } else if (type == "int8_t" || type == "byte") {
            emit(indent, "%s = R.read8();", lvalue.c_str());
        } else if (type == "boolean") {
             emit(indent, "%s = R.readBoolean();", lvalue.c_str());
        } else if (type == "string") {
             emit(indent, "%s = R.readString();", lvalue.c_str());
        } else {
            fprintf(stderr, "Unimpl decode type '%s' for lvalue='%s'\n", type.c_str(), lvalue.c_str());
        }
    }

    void emitDecode(const ZCMStruct& ls)
    {
        auto *sn = ls.structname.shortname.c_str();
        emit(0, "%s.decode = function(data)", sn);
        emit(0, "{");
        emit(1, "var R = createReader(data);");
        emit(1, "var hash = R.read64();");
        emit(1, "if (!hash.eq(%s.__get_hash_recursive())) {", sn);
        emit(1, "    console.error('Err: hash mismatch on %s');", sn);
        emit(1, "    return null;");
        emit(1, "}");
        for (auto& lm : ls.members) {
            auto& mtn = lm.type.fullname;
            auto& mn = lm.membername;
            int ndims = (int)lm.dimensions.size();
            if (ndims == 0) {
                emitDecodePrimType(1, "this." + mn, mtn);
            } else {
                emit(1, "this.%s = [];", mn.c_str());

                // For-loop open-braces
                char v = '_';
                for (int i = 0; i < ndims; i++) {
                    v = 'a'+i;
                    auto sz = dimSizeAccessor(lm.dimensions[i].size);
                    emit(i + 1, "for (var %c = 0; %c < %s; %c++) {", v, v, sz.c_str(), v);
                    if (i != ndims-1)
                        emit(i + 2, "var %celt = [];", v);
                };

                // For-loop bodies
                emitDecodePrimType(ndims + 1, "var " + string(1, v) + "elt", mtn);

                // For-loop close-braces
                for (int i = ndims-1; i >= 0; i--) {
                    char nextv = 'a'+i-1;
                    string array = (i == 0) ? "this."+mn : string(1, nextv)+"elt";
                    emit(i + 1, "    %s.push(%celt);", array.c_str(), v);
                    emit(i + 1, "}");
                    v = nextv;
                }
            }
        }

        emit(1, "return this;");
        emit(0, "};");
        emit(0, "");
    }

    void emitStruct(ZCMStruct& ls)
    {
        // XXX: should we be using fullname here?
        auto *sn = ls.structname.shortname.c_str();
        emit(0, "function %s()", sn);
        emit(0, "{");
        for (size_t i = 0; i < ls.members.size(); ++i)
            emit(1, "this.%s = undefined;", ls.members[i].membername.c_str());
        emit(0, "");
        for (size_t i = 0; i < ls.constants.size(); ++i) {
            static string hexPrefix = "0x";
            if (ls.constants[i].type == "int64_t") {
                if (ls.constants[i].valstr.size() > 2 &&
                    ls.constants[i].valstr.compare(0, hexPrefix.length(), hexPrefix) == 0)
                    emit(1, "this.%s = bigint(\"%s\", 16).toString();",
                            ls.constants[i].membername.c_str(), ls.constants[i].valstr.c_str() + 2);
                else
                    emit(1, "this.%s = bigint(\"%s\").toString();",
                            ls.constants[i].membername.c_str(), ls.constants[i].valstr.c_str());
            } else {
                emit(1, "this.%s = %s;",
                        ls.constants[i].membername.c_str(), ls.constants[i].valstr.c_str());
            }
        }
        emit(1, "%s.__get_hash_recursive([]);", sn);
        emit(0, "}");
        emit(0, "%s._hash = null;", sn);
        emit(0, "%s.__get_hash_recursive = function(parents)", sn);
        emit(0, "{");
        emit(1,     "if (%s._hash != null) return %s._hash", sn, sn);
        emit(1,     "if (parents.includes('%s')) return 0;", sn);
        for (auto& lm : ls.members) {
            if (!ZCMGen::isPrimitiveType(lm.type.fullname)) {
                emit(1, "newparents = parents.push('%s')", sn);
                break;
            }
        }
        emitStart(1, "var tmphash = bigint('%lu')", ls.hash);
        for (auto &lm : ls.members) {
            auto& msn = lm.type.shortname;
            if (!ZCMGen::isPrimitiveType(lm.type.fullname)) {
                const char *ghr = "__get_hash_recursive(newparents)";
                if (lm.type.fullname == ls.structname.fullname) {
                    emitContinue(".add(%s.%s)", msn.c_str(), ghr);
                } else {
                    //if (lm.type.package != "")
                    //    emitContinue(".add(%s.%s.%s)",
                    //                 lm.type.package.c_str(), msn.c_str(), ghr);
                    //else
                    emitContinue(".add(%s.%s)", msn.c_str(), ghr);
                }
            }
        }
        emitEnd (".and(UINT64_MAX);");

        emit(1, "%s._hash = rotateLeftOne(tmphash);", sn);
        emit(1, "return %s._hash;", sn);
        emit(0, "};");

        emitEncodedSize(ls);
        emitEncodeOne(ls);
        emitEncode(ls);
        emitDecode(ls);

        emit(0, "exports.%s = %s;", sn, sn);
        emit(0, "");
    }

    void emitModule()
    {
        emitHeader();
        for (auto& ls : zcm.structs) {
            emitStruct(ls);
        }
    }
};

int emitNode(ZCMGen& zcm)
{
    if (zcm.gopt->getBool("little-endian-encoding")) {
        printf("Nodejs does not currently support little endian encoding\n");
        return -1;
    }

    string npath = zcm.gopt->getString("npath");
    string fileName = npath + "/zcmtypes.js";
    EmitModule E{zcm, fileName};
    if (!E.good())
        return -1;

    E.emitModule();

    return 0;
}
